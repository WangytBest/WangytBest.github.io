{"pages":[{"title":"映像","text":"","link":"/gallery/index.html"},{"title":"黑客帝国","text":"","link":"/matrix/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"},{"title":"音乐播放器","text":"","link":"/music/index.html"},{"title":"我们","text":"","link":"/ours/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"时间轴","text":"","link":"/timeline/index.html"},{"title":"VIP","text":"","link":"/vip/index.html"}],"posts":[{"title":"MySQL安装教程","text":"1. 下载安装1.1 下载MySQL8.0 For Windows zip包下载地址：MySQL8.0 For Window，进入页面后可以不登录。后点击底部No thanks, just start my download.即可开始下载。或直接下载：https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.11-winx64.zip 1.2 安装解压zip包到安装目录 配置文件：在Windows系统中，配置文件默认是安装目录下的 my.ini 文件（或my-default.ini），部分配置需要在初始安装时配置，大部分也可以在安装完成后进行更改。当然，极端情况下，所有的都是可以更改的。 我们发现解压后的目录并没有my.ini文件，没关系可以自行创建。在安装根目录下添加 my.ini，比如我这里是：C:\\Program Files\\MySQL\\my.ini，写入基本配置： [mysqld] # 设置3306端口 port=3306 # 设置mysql的安装目录 basedir=C:\\Program Files\\MySQL # 设置mysql数据库的数据的存放目录 datadir=E:\\database\\MySQL\\Data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证 default_authentication_plugin=mysql_native_password [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [client] # 设置mysql客户端连接服务端时默认使用的端口 port=3306 default-character-set=utf8 注意，里面的 basedir 是本地的安装目录，datadir 是我数据库数据文件要存放的位置，各项配置需要根据自己的环境进行配置。查看所有的配置项，可参考：https://dev.mysql.com/doc/refman/8.0/en/mysqld-option-tables.html 2 初始化数据库在MySQL安装目录的 bin 目录下执行命令： mysqld --initialize --console 执行完成后，会打印 root 用户的初始默认密码，比如： C:\\Users\\Administrator>cd C:\\Program Files\\MySQL\\bin C:\\Program Files\\MySQL\\bin>mysqld --initialize --console 2018-04-28T15:57:17.087519Z 0 [System] [MY-013169] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server in progress as process 4984 2018-04-28T15:57:24.859249Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E 2018-04-28T15:57:27.106660Z 0 [System] [MY-013170] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server has completed C:\\Program Files\\MySQL\\bin> 注意！执行输出结果里面有一段： [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E 其中root@localhost:后面的rI5rvf5x5G,E就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。 3 安装数据库在MySQL安装目录的 bin 目录下执行命令（以管理员身份打开cmd命令行，或者在安装目录Shift+右键“在此处打开命令行窗口”）： mysqld --install [服务名] 后面的服务名可以不写，默认的名字为 mysql。 安装完成之后，就可以通过命令net start mysql启动MySQL的服务了。示例： C:\\Program Files\\MySQL\\bin>mysqld --install Service successfully installed. C:\\Program Files\\MySQL\\bin>net start mysql MySQL 服务正在启动 .. MySQL 服务已经启动成功。 4 修改密码在MySQL安装目录的 bin 目录下执行命令： mysql -u root -p 这时候会提示输入密码，记住了上面第1.3步安装时的密码，填入即可登录成功，进入MySQL命令模式。 修改密码: ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码'; [mysqld] default_authentication_plugin=mysql_native_password C:\\Program Files\\MySQL\\bin>mysql -u root -p Enter password: ************ Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 8.0.11 Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码'; Query OK, 0 rows affected (0.06 sec) mysql>","link":"/2018/05/29/MySQL安装教程/"},{"title":"URL操作处理","text":"URL /** * URL模块 * @param {[type]} require [description] * @param {[type]} exports [description] * @param {[type]} module [description] * @return {[type]} [description] */ define('url', function (require, exports, module) { var _cacheThisModule_; module.exports = { /** * 设置hash * @param name */ setHash: function (name) { setTimeout(function () { location.hash = name; }, 0); }, /** * 获取当前url中的hash值 * @param url * @return String */ getHash: function (url) { var u = url || location.hash; return u ? u.replace(/.*#/, \"\") : \"\"; }, /* * 根据hash获取对应的模块名 */ getHashModelName: function () { var hash = this.getHash(); return (hash ? hash.split(\"&amp;\")[0].split(\"=\")[0] : []); }, /* * 从hash中获取action */ getHashActionName: function () { var hash = this.getHash(); if (hash == \"\")return \"\"; return (hash ? hash.split(\"&amp;\") : [])[0].split(\"=\")[1]; }, /* * 从hash中获取name对应的值 */ getHashParam: function (name) { var result = this.getHash().match(new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\")); return result != null ? result[2] : \"\"; }, /* * 从URL中获取参数对应的值 */ getUrlParam: function (name, url) { //参数：变量名，url为空则表从当前页面的url中取 var u = arguments[1] || window.location.search, reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", 'i'), r = u.substr(u.indexOf(\"\\?\") + 1).match(reg); return r != null ? r[2] : \"\"; }, /* * 获取所有HASH的参数，剔除model. */ getParams: function () { var param = [], hash = this.getHash(); paramArr = hash ? hash.split(\"&amp;\") : []; for (var i = 1, l = paramArr.length; i &lt; l; i++) { param.push(paramArr[i]); } return param; }, decodeUrl: function (url) { url = decodeURIComponent(url); var urlObj = this.parseUrl(url), decodedParam = []; $.each(urlObj.params, function (key, value) { value = decodeURIComponent(value); decodedParam.push(key + \"=\" + value); }); var urlPrefix = url.split(\"?\")[0]; return urlPrefix + \"?\" + decodedParam.join(\"&amp;\"); }, parseUrl: function (url) { var a = document.createElement('a'); a.href = url; return { source: url, protocol: a.protocol.replace(':', ''), host: a.hostname, port: a.port, query: a.search, params: (function () { var ret = {}, seg = a.search.replace(/^\\?/, '').split('&amp;'), len = seg.length, i = 0, s; for (; i &lt; len; i++) { if (!seg[i]) { continue; } s = seg[i].split('='); ret[s[0]] = s[1]; } return ret; })(), file: (a.pathname.match(/([^\\/?#]+)$/i) || [, ''])[1], hash: a.hash.replace('#', ''), path: a.pathname.replace(/^([^\\/])/, '/$1'), relative: (a.href.match(/tps?:\\/\\/[^\\/]+(.+)/) || [, ''])[1], segments: a.pathname.replace(/^\\//, '').split('/') }; }, replaceParam: function (param, value, url, forceReplace) { url = url || location.href; var reg = new RegExp(\"([\\\\?&amp;]\" + param + \"=)[^&amp;#]*\"); if (!url.match(reg)) { return (url.indexOf(\"?\") == -1) ? (url + \"?\" + param + \"=\" + value) : (url + \"&amp;\" + param + \"=\" + value); } if (forceReplace) { return url.replace(reg, \"$1\" + value); } return url; } }; });","link":"/2018/05/30/URL操作处理/"},{"title":"Uncaught TypeError: angular.module(...).provider(...).info is not a function","text":"package.json中angular版本与ngSanitize版本不一致导致错误：Uncaught TypeError: angular.module(…).provider(…).info is not a function #github issue 上问题解答 尬，angular版本必须要与ngSanitize版本一致！ We do not support running core AngularJS that are at different versions. Can you explain why you would upgrade angular.js to 1.6.x but leave angular-sanitize.js at 1.5.x?","link":"/2017/09/14/Uncaught-TypeError-angular-module-provider-info-is-not-a-function/"},{"title":"React-JSX","text":"JSX语法 JSX 既不是字符串也不是HTML，是JavaScript的语法扩展，将被解析成JavaScript的一个对象。JSX用于生成React的“元素”。JSX中可以嵌入js表达式，用｛｝包裹。`javascriptfunction formatName(user) { return user.firstName + ‘ ‘ + user.lastName;} const user = { firstName: ‘Harper’, lastName: ‘Perez’} const element = ( Hello, {formatName(user)} !) ReactDOM.render( element, document.getElementById(‘root’)) &lt;iframe width=&quot;100%&quot; height=&quot;300&quot; src=&quot;//jsfiddle.net/wangyutao/z2pzn6xh/22/embedded/js,html,result/&quot; allowfullscreen=&quot;allowfullscreen&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; ### JSX指定属性 * 使用引号将字符串文字指定为属性值 ```javascript const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt; 使用花括号{}将JavaScript表达式嵌入属性中，｛｝中的变量不需要用””括起来，否则将解析为字符串const element = &lt;img src={user.avtarurl} /> JXS包含子标签 JSX可以包含子标签 JSX最外层只能包含一个标签，父标签内可以嵌套任意的子标签 JSX 标签内的属性命名约定使用 camelCase方式命名，而不是HTML属性名称 const element = ( &lt;div className=\"demo\"> &lt;h1>Hello!&lt;/h1> &lt;h2>Good to see you!&lt;/h2> &lt;/div> ) const elemtent = ( &lt;div tabIndex=\"0\">&lt;/div> ) JSX转换Bebel将JSX转换编译成React.createElement()对象。 const element = ( &lt;h1 className=\"greeting\"> Hello, World! &lt;/h1> ) const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, World!' ) 以上两种方式是等价的，最后都会转换成React Elements，这些对象组成页面的DOM并且保持更新。 解析为react Elements const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, World!' } }","link":"/2017/09/15/React-JSX/"},{"title":"canvas精灵","text":"requestAnimationFrame使用 canvas 实现精灵动画CREATE A SPRITE ANIMATION WITH HTML5 CANVAS AND JAVASCRIPTwindow.requestAnimationFrameCSS3动画那么强，requestAnimationFrame还有毛线用？HTML5 canvas drawImage() 方法","link":"/2018/04/18/canvas精灵/"},{"title":"cookie操作","text":"define(\"cookie\",function(require,exports,module){ var _cacheThisModule_; exports.get = getCookie; exports.set = setCookie; exports.del = delCookie; function getCookie(name) { //读取COOKIE var reg = new RegExp(\"(^| )\" + name + \"(?:=([^;]*))?(;|$)\"), val = document.cookie.match(reg); if(!val || !val[2]){return \"\";} var res = val[2]; try{ if(/(%[0-9A-F]{2}){2,}/.test(res)){//utf8编码 return decodeURIComponent(res); }else{//unicode编码 return unescape(res); } }catch(e){ return unescape(res); } } function setCookie(name, value, expires, path, domain, secure) { //写入COOKIES var exp = new Date(), expires = arguments[2] || null, path = arguments[3] || \"/\", domain = arguments[4] || null, secure = arguments[5] || false; expires ? exp.setMinutes(exp.getMinutes() + parseInt(expires)) : \"\"; document.cookie = name + '=' + escape(value) + ( expires ? ';expires=' + exp.toGMTString() : '') + ( path ? ';path=' + path : '') + ( domain ? ';domain=' + domain : '') + ( secure ? ';secure' : ''); } function delCookie(name, path, domain, secure) { //删除cookie var value = getCookie(name); if(value != null) { var exp = new Date(); exp.setMinutes(exp.getMinutes() - 1000); path = path || \"/\"; document.cookie = name + '=;expires=' + exp.toGMTString() + ( path ? ';path=' + path : '') + ( domain ? ';domain=' + domain : '') + ( secure ? ';secure' : ''); } } });","link":"/2018/05/30/cookie操作/"},{"title":"按钮点击水波效果","text":"Material Design设计按钮点击效果比较酷炫，每次点击按钮都会产生一次水波涟漪的效果。 可以css和canvas来实现这种效果。 css实现伪类（pseudo-class）和伪元素(peseudo-element) 伪类 :before :after 链接定义样式 :hover : 鼠标滑过元素上方时的展现效果 :active : 鼠标单击元素时展现效果 :visited : 已经单击过的链接 :link : 未访问、未滑过、未点击过的链接标签的样式 段落样式 :first-letter : 首字母 :first-line : 首行 设置元素 button元素在没有点击或者鼠标滑过时设置按钮样式,同时设置hover和active的样式效果 .button { text-decoration:none; user-select:none; position: relative; display: block; margin: 100px auto; width:120px; height:50px; line-height:50px; text-align:center; border-radius:25px; border: none; color:#fff; font-size:16px; cursor:pointer; background-color: #ff8300; box-shadow: 0 3px 9px 0 rgba(255, 131, 0, 0.35); overflow: hidden; } .button:hover { transform: translateY(-2px); box-shadow: 0 5px 13px 0 rgba(255, 131, 0, 0.59); } .button:active { box-shadow: 0 3px 9px 0 rgba(255, 131, 0, 0.35); color: #ffca8c; background-color: #f07b00; transform: translateY(0); } 添加水波效果 参考","link":"/2017/09/25/css-button-click/"},{"title":"CSS中的content和attr","text":"content和attr表达式，它们能在你的页面下面悄悄的使用CSS来生成内容，下面让我们看看attr和content如何相互配合产生神奇效果的。 基本content用法 content属性能让程序员使用CSS往页面元素里填写内容： .myDiv:after { content: \"我是一个使用*content*属性生产的静态文字\"; } 请注意，如果想让伪元素:after绝对定位，你必须对你的div设置position: relative。 content和attr配合使用如果你不想把content内容在CSS里写死，那你可以使用attr表达式来从页面元素中动态的获取内容： attr属性通常和自定义属性data-配合使用，因为传统的其它属性虽然也能存值，但通常不适合存放表达性文字。 /* &lt;div data-line=\"1\">&lt;/div> */ div[data-line]:after { content: attr(data-line); /* 属性名称上不要加引号！ */ } content里的字符串连接操作 content内容支持字符串的拼接 这种字符串连接很像常规编程语言了： /* &lt;div data-line=\"1\">&lt;/div> */ div[data-line]:after { content: \"[line \" attr(data-line) \"]\"; } 还需要用JavaScript里拼装字符串吗？CSS3里就能完成这些，是不是感觉CSS3可以部分的替代Javascript了！attr的动态生成页面内容的能力着实是一件让人兴奋的事情。你实际上可以用它配合content对页面的很多其他元素和属性进行操作。","link":"/2017/09/15/css-content-attr/"},{"title":"CSS实现元素水平垂直居中","text":"在前端开发过程中，盒子居中是常常用到的。其中 ，居中又可以分为水平居中和垂直居中。块级元素的水平居中比较容易，直接设置元素的margin: 0 auto就可以实现，垂直居中相对来说是比较复杂一些的。 高度位置，使用绝对定位.parentElem { position: relative; } .childElem { position: absolute; top: 50%; transform: translateY(-50%); } 父容器高度已知 且只有一个元素，只要使用相对定位即可 .parentElem { height: 200px; } .childElem { position: relative; top: 50%; transform: translateY(-50%); } 水平居中方案行内元素 text-aligin: center; 块级元素，宽度固定 margin: 0 auto; 块级元素，宽度不定 margin: 0 auto; vertical-align 垂直对齐 元素默认垂直对齐方式为基准对齐（baseline） 继承性： 不继承 适用于行内元素和单元格（table-cell）元素 语法 baseline : 基准线 middle : 中部对齐 top : 顶端对齐 bottom : 底端对齐 text-top : 与文本顶部对齐 text-bottom : 与文本底部对齐 sub : 下标 super : 上标 &lt;百分比&gt;，&lt;长度&gt; : 可为负数 inherit 图片本身没有基线，则将其底部与父元素的基线对齐。 参考：垂直对齐：vertical-align属性","link":"/2017/09/13/css-layout/"},{"title":"JS原生图片懒加载","text":"图片懒加载懒加载是前端优化的一种技术，旨在用户进入页面后，当滚动页面将要到达图片位置时才加载图片。加快页面加载速度，极大的提升了用户体验，也避免了用户进入页面之后就发送n多个图片请求，服务器吃不消啊！ 实现原理先将图片的src设置为空或者小的图片，将真实的图片地址存在img的自定义属性中，比如data-src中，等到页面滚动至图片位置时将真实图片位置复制给src属性。 页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片 用户滚动页面至图片位置时，img元素获取到真正的路径后，开始发送请求加载图片 JS中位置相关 screenLeft/screenX: 窗口相对于屏幕左边的位置 screenTop/screenY: 窗口相对于屏幕上边的位置 表示的是从屏幕左边和上边到window对象表示的可见区域的距离。 //FF中支持 screenX 和 screenY let leftPos = (typeof window.screenLeft == 'Number') ? window.screenLeft : window.screenX; let TopPos = (typeof window.screenTop == 'Number') ? window.screenTop : window.screenY; 若window对象是最外层对象，而且浏览器窗口贴紧屏幕上方，则 screenTop/screenY 为 0 clientWidth/clientHeight : 页面视口大小信息（ALL，注意获取方式） innerWidth/innerHeight : 获取页面视口大小（页面尺寸）,页面视图容器大小 outerWidth/outerHeight : 获取浏览器窗口本身的大小（IE9+、Safari、FF） let pageWidth = window.innerWidth; let pageHeight = window.innerHeight; if( typeof pageWidth != 'Number'){ if(document.compatMode == 'CSS!Compat'){ //标准模式 pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; } else { //怪异模式（混杂模式） pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; } } 懒加载实现var imgCurrent = 4;//初始化页面加载图片个数 var imgCount = 40;//总图片数 var height = document.body.clientHeight || document.documentElement.clientHeight; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; var clientHeight = Math.min(document.documentElement.scrollHeight, document.documentElement.clientHeight); var img = document.getElementsByTagName('img'); window.onscroll = null; window.onscroll = () => { //图片懒加载 for (var i = imgCurrent; i &lt; imgCount; i++) { if (img[i].offsetTop &lt; clientHeight + scrollTop) { img[i].src = img[i].getAttribute('data-src'); img[i].style.opacity = 1; imgCurrent = i + 1; console.log('图片加载[' + i + ']:' + img[i].src); } } }; 补充 偏移量(offset) offsetWidht : 元素在水平方向上占用的空间大小。包括元素的宽度、水平滚动条的宽度、左右边框的宽度。 offsetHeight : 元素在垂直方向上占用的空间大小。包括元素的高度、垂直滚动条的高度、上下边框的高度。 offsetLeft : 元素的左边框至包含元素的左内边距的距离。（offsetParent） offsetTop : 元素的上边框至包含元素的上内边距的距离。（offsetParent） ```offsetTop``` 和 ```offsetLeft``` 与其包含元素```offsetParent```有关。```offsetParent```的值不一定与```parentNode```相同。 这些偏移量属性均为**只读**。 ![偏移量 offset](http://cloud.xuww.wang/offset.jpg) #### 客户区大小（```client dismension```） > * clientWidth : 元素内容区宽度加上左右内边距。```content + padding-left + padding-right clientHeight : 元素内容区高度加上上下内边距。content + padding-top + padding-bottom client dismension 值也是只读的。 let clientWidth = document.documentElement.clientWidht; let clientHeight = document.documentElement.clientHeight; 滚动大小（scroll dismension） scrollTop : 被隐藏在内容区域上方的高度。（上方被隐藏了多少） scrollLeft : 被隐藏在内容区域左侧的宽度。（左侧被隐藏了多少） scrollWidth : 在没有滚动的情况下，元素内容的总宽度。 scrollHeight : 在没有滚动的情况下，元素内容的总高度。 带有垂直滚动条的页面总高度：document.documentElement.scrollHeight 带有水平滚动条的页面总宽度：document.documentElement.scrollWidth 通过scrollLeft和scrollTop既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。 // 确定文档的总高度 //scrollHeight和clientHeight中的最大值 let docHeight = Math.max(documnt.documentElement.scrollHeight, document.documntElement.clientHeight); // 确定文档的总宽度 //scrollWidth和clientWidth中的最大值 let docWidth = Max.max(document.documentElement.scrollWidth, document.documentElement.clientWidth);","link":"/2017/09/20/css-lazy-load-image/"},{"title":"SVG基础入门","text":"可缩放矢量图形，即SVG，是W3C XML的分枝语言之一，用于标记可缩放的矢量图形。（摘自MDN） version： 表示&lt;svg&gt;的版本 xmlns：http://www.w3.org/2000/svg 固定值 xmlns:xlink：http://www.w3.org/1999/xlink 固定值 xml:space：preserve 固定值，上述三个值固定，表示命名空间，当数据单独存在svg文件内时，这3个值不能省略 class: class类名 width | height： 定义 svg 画布的大小 viewbox： 定义了画布上可以显示的区域，当 viewBox 的大小和 svg 不同时，viewBox 在屏幕上的显示会缩放至 svg 同等大小。 有了 svg 标签，我们就可以愉快的在内部添加 SVG 图形了。 &lt;?xml version=\"1.0\" standalone=\"no\"?> &lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"> &lt;svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"> &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\"/> &lt;/svg> 第一行包含了 XML 声明。standalone 属性规定此 SVG 文件是否是“独立的”，或含有对外部文件的引用。standalone=”no” 意味着 SVG 文档会引用一个外部文件。 SVG 代码以 &lt;svg&gt;元素开始，包括开启标签 &lt;svg&gt; 和关闭标签&lt;/svg&gt; 。width 和 height 属性可设置此 SVG 文档的宽度和高度。version属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。","link":"/2017/09/27/css-svg-basic/"},{"title":"css文字两端对齐","text":"文本内容可以实现左对齐、右对齐以及居中对齐，如何实现两端对齐？很多时候为了对齐文字中间使用空格来隔开，这样每个内容需要计算空格个数，当内容不一样长短的时候又通过JS进行麻烦的计算。 text-align是控制文字的对齐与显示，从其属性名上就可以看出来。从其渲染与解析上来看，其主要是用来控制inline水平元素或inline-block元素的对齐与显示的，例如嵌套行内标签的文字、图片、input表单控件等；而对block水平的元素是没有作用的。 text-align: center | left | right | start | end | justify | inherit | initial | unset text-align: justify css2中text-align有一个属性为justify，居中对齐。其实现的效果就是可以让一行文字两端对齐显示（文字内容要超过一行） 有多行文字 多行文字内容时直接使用justify可以实现两端对齐效果 &lt;div>Vue.js (读音 /vjuː/，类似于 view) 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。&lt;/div> div { width: 500px; border: 1px solid #000; text-align: justify; } 只有一行文字 需要在文字后面加一个占位元素，可以使用伪类元素实现，或者加&lt;span&gt;&lt;/span&gt;、&lt;i&gt;&lt;/i&gt;空元素。 &lt;div>css文字两端对齐！&lt;/div> div { width: 500px; border: 1px solid #000; text-align: justify; } 此时的效果并没有实现两端对齐，因为文字内容没有换行。可以使用伪类元素实现。 div { width: 500px; border: 1px solid #000; text-align: justify; } div:after { content: ''; display: inline-block; width: 100%; }","link":"/2017/10/16/css-text-align-justify/"},{"title":"css控制文本内容溢出截断","text":"css控制文字内容的溢出显示，溢出截断后末尾出现省略...，单行文本与多行文本的控制又有区别。单行文本 overfolw: hidden; text-overflow: ellipsis; white-space: nowrap; 多行文本 display:-webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; overflow: hidden; 知识点 text-overflow 确定内容的溢出显示，可以被剪切(clip)、显示一个省略号（...）或者显示一个自定义字符串。 需要设置overflow: hidden属性才能生效，否则不会强制溢出事件发生。 属性只对块级元素溢出的内容有效，但必须与块级元素内联（inline）方向一致。如内容在盒子下方溢出，则属性不会生效。 文本溢出：1、文本无法换行，设置了white-space: nowrap;。2、单词太长。 text-overflow: [ clip | ellipise | &lt;string> ]{1, 2} clip: 内容区域的极限处截断文本，因此可能在字符的中间可能会发生截断。为了能够在两个字符过度处截断，必须使用一个空字符串值（）。 ellipse: 用省略号...来表示截断的文本。如果空间太小连省略号也不能显示，那么省略号也会被截断。 &lt;string&gt;: &lt;string&gt;用来表示被截断的文本。字符串内容将被添加在内容区域中，所以会减少显示出的文本。如果空间太小到连省略号的容纳下，那么这个字符串也会被截断。 /* Overflow behavior at line end Right end if ltr, left end if rtl */ text-overflow: clip; text-overflow: ellipsis; text-overflow: \"…\"; text-overflow: fade; text-overflow: fade(10px); text-overflow: fade(5%); /* Overflow behavior at left end | at right end Directionality has no influence */ text-overflow: clip ellipsis; text-overflow: \"…\" \"…\"; text-overflow: fade clip; text-overflow: fade(10px) fade(10px); text-overflow: fade(5%) fade(5%); /* Global values */ text-overflow: inherit; text-overflow: initial; text-overflow: unset; div br{ display: none; } CSS value direction: ltr direction: rtl Expected Result Live result Expected Result Live result visible overflow 1234567890 1234567890 0987654321 1234567890 text-overflow: clip 123456 1234567890 text-overflow: ‘’ 12345 123456 54321 1234567890 text-overflow: ellipsis 1234… 1234567890 …4321 1234567890 text-overflow: ‘.’ 1234. 1234567890 .4321 1234567890 text-overflow: clip clip 123456 1234567890 654321 1234567890 text-overflow: clip ellipsis 1234… 1234567890 6543… 1234567890 text-overflow: clip ‘.’ 1234. 1234567890 6543. 1234567890 text-overflow: ellipsis clip …3456 1234567890 …4321 1234567890 text-overflow: ellipsis ellipsis …34… 1234567890 …43… 1234567890 text-overflow: ellipsis ‘.’ …34. 1234567890 …43. 1234567890 text-overflow: ‘,’ clip ,3456 1234567890 ,4321 1234567890 text-overflow: ‘,’ ellipsis ,34… 1234567890 ,43… 1234567890 text-overflow: ‘,’ ‘.’ ,34. 1234567890 ,53. 1234567890","link":"/2017/10/19/css-text-overflow/"},{"title":"flex布局在UC和微信浏览器下的兼容性问题","text":"flex布局UC和微信浏览器下的兼容性问题所有webkit内核的浏览器（包括移动端）都支持 flex 布局，只不过一些浏览器只支持旧语法，如：display: -webkit-box 。旧语法和标准的 flex 语法有较大区别，需要做好兼容。不过可以来使用 autoprefixer 来自动处理这些兼容性问题，而开发时只需要写标准的语法就好了。 假如没有使用autoprefixer，在UC浏览器和微信内置浏览器中，使用display:flex;时会不起作用，要加上兼容性写法。 display: -webkit-box; /* OLD - iOS 6-, Safari 3.1-6 */ display: -moz-box; /* OLD - Firefox 19- (buggy but mostly works) */ display: -ms-flexbox; /* TWEENER - IE 10 */ display: -webkit-flex; /* NEW - Chrome */ display: flex; 使用flex:1;时也要添加兼容性写法 width: 20%; /* For old syntax, otherwise collapses. */ -webkit-box-flex: 1; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex: 1; /* OLD - Firefox 19- */ -webkit-flex: 1; /* Chrome */ -ms-flex: 1; /* IE 10 */ flex: 1; flex.css","link":"/2018/04/03/flex布局在UC和微信浏览器下的兼容性问题/"},{"title":"清空git缓存","text":"清空git缓存 git rm -r --cached . git add . git commit -m 'update .gitignore'","link":"/2017/09/25/git-rm-cache/"},{"title":"git基础","text":"github上创建新的项目后，在本地拉取项目或者将本地的项目关联到建立的仓库。 # git clone git@github.com:xxxxxxxxx.git 命令行新建一个新的仓库# mkdir myProject # cd myProject # echo '# my new project' >> README.md # git init # git add . # git commit -m \"first commit\" # git remote add origin git@github.com:xxxxxxxxx.git # git push origin master 本地项目关联远程git仓库# cd myProject # git remote add origin git@github.com:xxxxx/xxxx/git # git push origin master 本地分支关联远程分支# git checkout test # git remote add origin git@github.com:xxxx/test.git fatal首次拉取代码失败 git pull错误信息 : * branch master -> FETCH_HEAD fatal: refusing to merge unrelated histories 解决： # git pull origin master --allow-unrelated-histories 首次安装git设置# git config -global user.nme \"xxxxxx\" # git config -global user.email \"xxxxxx@jd.com\" 公钥密钥配置# ssh-keygen -t rsa 会生成两个文件：id_rsa（密钥）和id_rsa.pub（公钥）在github中设置公钥。","link":"/2017/10/13/github-project-init/"},{"title":"AJAX异步请求","text":"AJAX： Asyncchronous Javascript + XMLLAjax的技术核心是XMLHttpRequest对象，简称XHR。 XMLHttpRequest对象（XHR） 以异步的方式从服务器获取数据，获取新数据后，通过DOM的方式将新数据插入到页面中。 1. 新建XHR对象 IE7+、现代浏览器都支持原生的XHR对象 var xhr = new XMLHttpRequest(); 2. open(method, url, boolean) open() 方法并不会真正发送请求，而是启动一个请求以备发送。同域、同端口、同协议 method: 发送请求的类型（get、post、delete、put等） url： 请求URL（相对路径是相对于当前页面或者绝对路径） boolean： 是否异步发送请求 3. send() 一个参数，作为请求主体发送的数据，或者为null（body中的数据）默认情况下，服务器对POST请求和表单提交的请求不会一视同仁。因此服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分。可以使用XHR来模仿表单提交： 1、将content-Type头部信息设置成application/x-www-form-urlencoded 2、serialize()函数序列化表单内容。 收到相应请求后，响应数据会自动填充XHR对象的属性。 responseText 作为响应主体被返回的文本。 responseXML 如果响应类型是text/xml或者application/xml，这个属性中保存着包含响应数据的XML DOM文档。 status HTTP响应状态 statusText HTTP响应状态说明 异步请求，检测XHR对象的readyState属性，该属性表示请求/响应过程中的当前活动阶段。 0 ： 未初始化。尚未调用open()方法。 1 ： 启动。已经调用open()方法， 但未调用send()方法。 2 ： 发送。已经调用send()方法， 但未接收到响应。 3 ： 接收。已经接收到部分响应数据。 4 ： 完成。已经接收到全部响应数据，已经可以在客户端使用。 readyState值变化都会触发readystatechange事件。 同步方式请求var xhr = new XMLHttpRequest(); xhr.open('get', 'example.json', false); xhr.send(null); if((xhr.status > 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ //xhr.responseText; //通过检测xhr.status来检测请求返回状态，不要依赖statusText，因为跨浏览器时statusText不可靠 }else{ //请求错误, 输出错误log：xhr.status } 异步方式请求var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status > 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){ alert(xhr.reponseText); }else{ alert(\"Request was unsuccessful: \" + xhr.status); } } xhr.open('get', 'example.json', true); xhr.send(null); 4. 取消异步请求xhr.abort() 5.HTTP头部信息 Accept 浏览器处理的内容类型 Accept-Charset 显示的字符集 Accept-Econding 处理的压缩编码 Connection 与服务器之间的连接类型 Cookie Cookie设置 Host 发出请求所在的域 Referer 发出请求坐在的URI xhr.setRequestHeader('HeaderName', 'HeaderVal'); 使用自定义的头部字段名称，有些浏览器禁止修改默认的头部字段 。xhr.getResponseHeader('HeaderName');xhr.getAllResponseHeaders(); function create_connect_obj(){ if(window.ActiveXObject!='undefined' &amp;&amp; window.ActiveXObject!=undefined){ // 兼容IE7以下，可以忽略 return new ActiveXObject('Microsoft.XMLHTTP'); }else if(window.XMLHttpRequest!='undefined' &amp;&amp; window.XMLHttpRequest!=undefined){ return new XMLHttpRequest(); } } var doget=function(url,data,success,fail){ var conn=create_connect_obj(); if(typeof(data)=='object'){ var str=''; for(var i in data){ str+='&amp;'+i+'='+data[i]; } str=str.substr(1); if(url.indexOf('?')!=-1){ url+=str; }else{ url+='?'+str; } }else if(typeof(data)=='string'){ if(url.indexOf('?')!=-1){ url+=data; }else{ url+='?'+data; } } conn.open('GET',url); conn.send(null); conn.onreadystatechange=function(){ if(conn.readyState==4 &amp;&amp; conn.status==200){ if(typeof(data)=='function'){ data(conn.response); }else if(typeof(success)=='function'){ success(conn.response); //success } }else{ if(typeof(fail)=='function'){ //fail fail(); } } } } var dopost=function(url,data,success,fail){ var conn=create_connect_obj(); conn.open('POST',url); conn.setRequestHeader('Content-type','application/x-www-form-urlencoded'); if(typeof(data)=='object'){ var str=''; for(var i in data){ str+='&amp;'+i+'='+data[i]; } str=str.substr(1); conn.send(data); }else if(typeof(data)=='string'){ conn.send(data); }else{ conn.send(null); } conn.onreadystatechange=function(){ if(conn.readyState==4 &amp;&amp; conn.status==200){ if(typeof(data)=='function'){ data(conn.response); }else if(typeof(success)=='function'){ success(conn.response); //success } }else{ if(typeof(fail)=='function'){ //fail fail(); } } } }","link":"/2017/09/26/javascript-ajax/"},{"title":"JS控制GIF动画","text":"JS控制Gif动画 思想： 使用canvas获取Gif第一帧图片，静止的时候使用图片，播放的时候使用Gif。 if ('getContext' in document.createElement('canvas')) { HTMLImageElement.prototype.play = function() { if (this.storeCanvas) { // 移除存储的canvas this.storeCanvas.parentElement.removeChild(this.storeCanvas); this.storeCanvas = null; // 透明度还原c this.style.opacity = ''; } if (this.storeUrl) { this.src = this.storeUrl; } }; HTMLImageElement.prototype.stop = function() { // polyfill 提供了这个方法用来获取设备的 pixel ratio let getPixelRatio = function(context) { let backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1; return (window.devicePixelRatio || 1) / backingStore; }; let canvas = document.createElement('canvas'); let ratio = getPixelRatio(canvas); // 尺寸 let width = +this.width; let height = +this.height; if (width &amp;&amp; height) { // 存储之前的地址 if (!this.storeUrl) { this.storeUrl = this.src; } // canvas大小 canvas.width = width * ratio; canvas.height = height * ratio; // 绘制图片帧（第一帧） // 注意，这里的 width 和 height 变成了 width * ratio 和 height * ratio canvas.getContext('2d').drawImage(this, 0, 0, width * ratio, height * ratio); canvas.style.width = width; canvas.style.height = height; // 重置当前图片 try { this.src = canvas.toDataURL('image/gif'); } catch (e) { console.log(e); // 跨域 this.removeAttribute('src'); // 载入canvas元素 canvas.style.position = 'absolute'; // 前面插入图片 this.parentElement.insertBefore(canvas, this); // 隐藏原图 this.style.opacity = '0'; // 存储canvas this.storeCanvas = canvas; } } }; }","link":"/2018/02/02/js-contro-gif-md/"},{"title":"localstroge本地缓存","text":"localStorage设置过期时间 define(\"localStorage\", function(require, exports, module){ var cache = require(\"cachev1\").local; var Promise = require(\"promise.min\"); /** * 将过期时间字符串转换成时间戳 * convertExpire(\"7d\") * convertExpire(3600) 1小时 * @param {String} val 过期时间，格式为`\\d+[smhd]`，其中s 表示秒、m 分钟、h 小时、d 天，如 30d 默认是秒 * @return {Number} 时间戳（单位s） */ function convertExpire(val) { if (!val) return 0; var matches = ('' + val).match(/(\\d+)([smhd])/); var ms = 0; if (matches) { switch (matches[2]) { case 's': ms = matches[1]; break; case 'm': ms = matches[1] * 60; break; case 'h': ms = matches[1] * 60 * 60; break; case 'd': ms = matches[1] * 24 * 60 * 60; } } else{ ms = val; } return ms; } var timeout = setTimeout; var storage = { /** * 将数据写入本地缓存 * * @param {String} key 键名 * @param {Object | String} value 数据 * @param {Object} options 可选项，可传expire 设定数据过期时间，格式参见convertExpire * * @return {Promise} Promise实例 */ set:function(key, value, options) { return new Promise(function(resolve, reject){ var expire = convertExpire(typeof options == 'object' &amp;&amp; options.expire ? options.expire : '7d'); timeout(function () { cache.setItem(key,value,expire,function (ret) { if(ret==0) resolve(); else reject(); }); }); }) }, /** * 获取本地缓存数据，当数据已过期时会被清理掉 * * @param {String} key 键名 * @param {Mix} defaultVal 如设置了默认值，则保证不会被reject * * @return {Promise} Promise实例 */ get:function(key, defaultVal) { return new Promise(function(resolve, reject){ timeout(function () { var value = cache.getItem(key); if(value===\"\"||value===null){ if(typeof defaultVal!=\"undefined\"){ resolve(defaultVal); }else{ reject(); } return; } resolve(value); }); }) }, /** * 移除本地缓存数据 */ remove:function(key) { return new Promise(function(resolve, reject){ timeout(function () { cache.removeItem(key); resolve(); }); }) }, /** * 同步地设置本地缓存数据 * * @deprecated 此方法只为了暂时兼容旧接口，会极大的影响性，能请勿使用！ */ setSync:function(key, value, options) { var expire = convertExpire(typeof options == 'object' &amp;&amp; options.expire ? options.expire : '7d') cache.setItem(key,value,expire); }, /** * 同步地获取本地缓存数据，当数据已过期时会被清理掉 * * @deprecated 此方法只为了暂时兼容旧接口，会极大的影响性，能请勿使用！ */ getSync:function(key) { return cache.getItem(key); } } module.exports = storage; });","link":"/2018/05/30/localstroge本地缓存/"},{"title":"margin、padding的百分比计算","text":"CSS2.1 Box model The percentage is calculated with respect to the width of the generated box’s containing block. Note that this is true for margin-top and margin-bottom as well. margin：百分比的计算基于生成框的包含块(父元素)的width（margin-top/bottom也是如此）。padding同理","link":"/2018/04/20/margin、padding的百分比计算/"},{"title":"sass基础入门","text":"css功能拓展嵌套（Nested Rules）sass允许将css样式嵌套进另一套样式中，内层的样式将他的外层的选择器作为父选择器。 父选择器 &amp; (Referencing Parent Selectors: &amp;)属性嵌套 (Nested Properties).funky { font: { family: fantasy; size: 30em; weight: bold; } } 占位符选择器 %foo (Placeholder Selectors: %foo) SassScript变量 $ (Variables: $)$width: 5em; #main { width: $width; } 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明 #main { $width: 5em !global; width: $width; } #sidebar { width: $width; }","link":"/2018/04/03/sass基础入门/"},{"title":"微信小程序使用阿里字体图标","text":"前言为了美化微信小程序，可以使用适当的图标来美化页面，体验更好。阿里字体图标库提供了丰富的字体，各种场景下项目中所需要字体几乎都能找到。 微信小程序中设置元素的背景图片不能使用本地图片，本地资源无法通过WXSS获取，background-img可以使用网络图片或者base64，或者使用image标签，所以不能直接下载阿里字体图标库的图片设置为背景图片，可以将下载的图片转成字体文件使用。 使用1. 下载字体 2. 解压转成base64文件下载字体文件，解压缩后将.ttf文件转化，transfonter 3. 拷贝字体文件至小程序将下载好的文件夹中stylesheet.css样式表中的内容拷贝, 粘贴至小程序的wxss文件中,即可引用该iconfont字体图标. 4. 引用字体文件小程序只能识别wxss为后缀的css文件，不能识别.css文件。@import &quot;/assets/iconfont/iconfont.wxss","link":"/2018/03/21/微信小程序使用阿里字体图标/"},{"title":"webpack插件关于autoprefixer的冲突","text":"1. 实际遇到的问题项目中经常会遇到css的一些奇怪问题，有些css属性的设置在在本地编译运行的时候是好的，但是打包上线之后这个属性就平白无故的没有了？ 具体场景 在处理多行文本溢出时，需要使用-webkit-box-orient: vertial，在本地开发测试一切正常，但是在webpack编译之后，检查样式并没有这个属性，其他的属性都有。 // 多行文本 @mixin textmultiline($line:2) { display: -webkit-box; /* autoprefixer: off*/ -webkit-box-orient: vertical; /* autoprefixer: on*/ -webkit-line-clamp: $line; overflow: hidden; text-overflow: ellipsis; } 2. 为什么啊？ why remove -webkit-box-orient property? #357 Autoprefixer setting should be false by default #252 原因： autoprefixer自动的删除了一些它觉得没有必要的属性，所以解决办法就是设autoprefixer为false，或者针对某个属性忽autoprefixer 3. 怎么办 属性忽略autoprefixer // eslint-disable-next-line /* autoprefixer: off*/ -webkit-box-orient: vertical; /* autoprefixer: on*/ 关闭cssnano的autoprefixer just remove the postcss config in vue-loader’s config Add the following option to prevent autoprefixer from removing prefixes (for cssnano v3 only): { autoprefixer: { remove: false } } Then -webkit-box-orient will be preserved. optimize-css-assets-webpack-plugin 插件问题 new OptimizeCSSPlugin({ cssProcessorOptions: config.build.productionSourceMap ? { safe: true, map: { inline: false } } : { safe: true } }),","link":"/2018/08/27/webpack-插件关于autoprefixer的冲突/"},{"title":"数组对象判断","text":"数组对象判断方法 支付宝base.jsif ( value instanceof Array || (!(value instanceof Object) &amp;&amp; (Object.prototype.toString.call((value)) == '[object Array]') || typeof value.length == 'number' &amp;&amp; typeof value.splice != 'undefined' &amp;&amp; typeof value.propertyIsEnumerable != 'undefined' &amp;&amp; !value.propertyIsEnumerable('splice'))) { return 'array'; } instanceofvar arr = []; arr instanceof Array; // true arr.constructor == Array; //true call/applyObject.prototype.toString.call(value) == '[object Array]' var isArray = function(obj) { return Object.prototype.toString.call(obj) === '[object Array]'; } typeof typeof方法返回一个字符串，来表示数据的类型。 数据类型 type 数据类型 Type Undefined undefined Null object 布尔值 boolean 数值 number 字符串 string Symbol (ECMAScript 6 新增) symbol 宿主对象(JS环境提供的，比如浏览器) Implementation-dependent 函数对象 function 任何其他对象 object var a = []; var b = {}; typeof a; // \"object\" typeof b; // \"object\" a instanceof Object // true b instanceof Object // true a instanceof Array // true b instanceof Array // false","link":"/2018/04/12/数组对象判断/"},{"title":"时间处理","text":"时间处理方法 define(\"date\",function(require,exports,module){ var _cacheThisModule_; exports.format = function(date,formatStr){ //格式化时间 var arrWeek=['日','一','二','三','四','五','六'], str=formatStr .replace(/yyyy|YYYY/,date.getFullYear()) .replace(/yy|YY/,$addZero(date.getFullYear() % 100,2) ) .replace(/mm|MM/,$addZero(date.getMonth()+1,2)) .replace(/m|M/g,date.getMonth()+1) .replace(/dd|DD/,$addZero(date.getDate(),2) ) .replace(/d|D/g,date.getDate()) .replace(/hh|HH/,$addZero(date.getHours(),2)) .replace(/h|H/g,date.getHours()) .replace(/ii|II/,$addZero(date.getMinutes(),2)) .replace(/i|I/g,date.getMinutes()) .replace(/ss|SS/,$addZero(date.getSeconds(),2)) .replace(/s|S/g,date.getSeconds()) .replace(/w/g,date.getDay()) .replace(/W/g,arrWeek[date.getDay()]); return str; } exports.getTimeDistance = function (ts){ //根据时间差计算剩余的时间，返回[天，小时，分，秒] var timeLeft=[0,0,0,0];//结构：天、小时、分、秒 timeLeft[0]=(ts>86400)?parseInt(ts/86400):0; ts=ts - timeLeft[0] * 86400; timeLeft[1]=(ts>3600)?parseInt(ts/3600):0; ts=ts - timeLeft[1] * 3600; timeLeft[2]=(ts>60)?parseInt(ts/60):0; timeLeft[3]=ts - timeLeft[2] * 60; return timeLeft; } exports.getTimeInterval = function (st,et){ //返回两个时间之间的间隔的描述字符串 var dateLeft = 0; var hourLeft = 0; var minuteLeft = 0; var secondLeft = 0; var timeLeft=[0,0,0,0];//结构：天、小时、分、秒 var timeStr=\"\"; var ts=(et>st)?parseInt((et-st)/1000):0; timeLeft[0]=(ts>86400)?parseInt(ts/86400):0; ts=ts - timeLeft[0] * 86400; timeLeft[1]=(ts>3600)?parseInt(ts/3600):0; ts=ts - timeLeft[1] * 3600; timeLeft[2]=(ts>60)?parseInt(ts/60):0; timeLeft[3]=ts - timeLeft[2] * 60; timeStr=(timeLeft[0]>0)?timeLeft[0]+\"天\":\"\"; timeStr+=(timeLeft[0]&lt;=0 &amp;&amp; timeLeft[1]&lt;=0)?\"\":(timeLeft[1]+\"小时\"); timeStr+=(timeLeft[0]&lt;=0 &amp;&amp; timeLeft[1]&lt;=0 &amp;&amp; timeLeft[2]&lt;=0)?\"\":(timeLeft[2]+\"分钟\"); timeStr+=(timeLeft[0]&lt;=0 &amp;&amp; timeLeft[1]&lt;=0 &amp;&amp; timeLeft[2]&lt;=0 &amp;&amp; timeLeft[3]&lt;=0)?\"\":timeLeft[3]+\"秒\"; return timeStr; } function $addZero(v,size){ for(var i=0,len=size-(v+\"\").length;i&lt;len;i++){ v=\"0\"+v; }; return v+\"\"; } exports.getServerTime = function(url) { var sysTime = document.getElementById('SYSTIME'); if(sysTime){ var ts = sysTime.value.substring(0, 19).split('-'), dObj = new Date(ts[0], parseInt(ts[1], 10) - 1, ts[2], ts[3], ts[4], ts[5]); return dObj; } var xhr = $xhrMaker(), url = url || \"http://\" + window.location.hostname+\"/favicon.ico\"; try{ xhr.open(\"HEAD\", url, false); xhr.send(); }catch(e){ return new Date(); } return new Date(xhr.getResponseHeader(\"Date\")); } function $xhrMaker(){ var xhr; try{// Firefox, Opera 8.0+, Safari xhr=new XMLHttpRequest(); }catch(e){//Internet Explorer try{ xhr=new ActiveXObject(\"Msxml2.XMLHTTP\"); }catch(e){ try { xhr=new ActiveXObject(\"Microsoft.XMLHTTP\"); }catch (e){ xhr=null; } } }; return xhr; } });","link":"/2018/05/30/时间处理/"},{"title":"vue中keep-alive","text":"keep-alive使用&lt;keep-alive&gt;包裹动态的组件，会缓存不活动的组件实例，而不是销毁他们。&lt;keep-alive&gt;是一个抽象的组件，他自身不会渲染一个DOM元素，也不会出现在父组件链中。当组件在&lt;keep-alive&gt;组件内被切换，它的actived和deactived这两个生命周期钩子函数将会被对应执行。 Vue2.2.0及以上版本，activated 和 deactivated 将会在 &lt;keep-alive&gt; 树内的所有嵌套组件中触发。主要用于保留组件状态或避免重新渲染。 当引入&lt;keep-alive&gt;的时候，页面第一次进入，钩子的触发顺序created -&gt; mounted -&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。 &lt;keep-alive&gt;之后页面模板第一次初始化解析变成HTML片段后，再次进入就不在重新解析而是读取内存中的数据，即，只有当数据变化时，才使用VirtualDOM进行diff更新。故，页面进入的数据获取应该在activated中也放一份。数据下载完毕手动操作DOM的部分也应该在activated中执行才会生效。 所以，应该activated中留一份数据获取的代码，或者不要created部分，直接将created中的代码转移到activated中。 &lt;!-- 基本 --> &lt;keep-alive> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;!-- 多个条件判断的子组件 --> &lt;keep-alive> &lt;comp-a v-if=\"a > 1\">&lt;/comp-a> &lt;comp-b v-else>&lt;/comp-b> &lt;/keep-alive> &lt;!-- 和 `&lt;transition>` 一起使用 --> &lt;transition> &lt;keep-alive> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;/transition> include 和 excludeinclude 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示： &lt;!-- 逗号分隔字符串 --> &lt;keep-alive include=\"a,b\"> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;!-- 正则表达式 (使用 `v-bind`) --> &lt;keep-alive :include=\"/a|b/\"> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> &lt;!-- 数组 (使用 `v-bind`) --> &lt;keep-alive :include=\"['a', 'b']\"> &lt;component :is=\"view\">&lt;/component> &lt;/keep-alive> actived 和 deactived 类型：Function 说明：&lt;keep-alive&gt;组件 激活/停用 时调用（该钩子在服务器端渲染期间不被调用） 应用项目开发中，使用Vue2.0 搭配路由切换vue-router，所有路径匹配到的视图组件都会被缓存。如何使某些组件不缓存？ &lt;keep-alive> &lt;router-view> &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --> &lt;/router-view> &lt;/keep-alive> #1. 使用include和exclude &lt;keep-alive include='a,b,c' exclude='d,e,f'> &lt;router-view> &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --> &lt;/router-view> &lt;/keep-alive> #2. 使用router.meta属性设置路由，通过meta属性判断组件是否需要缓存 // routes 配置 export default [ { path: '/', name: 'home', component: Home, meta: { keepAlive: true // 需要被缓存 } }, { path: '/:id', name: 'edit', component: Edit, meta: { keepAlive: false // 不需要被缓存 } } ] &lt;keep-alive> &lt;router-view v-if=\"$route.meta.keepAlive\"> &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --> &lt;/router-view> &lt;/keep-alive> &lt;router-view v-if=\"!$route.meta.keepAlive\"> &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --> &lt;/router-view> 部分转载vue-router 之 keep-alive","link":"/2018/04/03/vue中keep-alive/"},{"title":"浏览器判断","text":"移动端判断浏览器环境： 微信浏览器 小程序 JD APP 浏览器 const uaTypes = { APP: 'app', WECHAT: 'webchat', QQ: 'qq', MOBILE: 'mobile' } const ua = navigator.userAgent const type = (() => { if (/jdapp/i.test(ua)) { return uaTypes.APP } else if (/MicroMessenger/i.test(ua)) { return uaTypes.WECHAT } else if (/QQ/.test(ua)) { // 区分手机QQ和QQ浏览器 if (/MQQBrowser/i.test(ua)) { return uaTypes.MOBILE } else { return uaTypes.QQ } } else { return uaTypes.MOBILE } })()","link":"/2018/05/18/浏览器判断/"},{"title":"移动端适配方案","text":"视窗（viewport）简单理解viewport就是浏览器窗口大小。在桌面浏览器中，viewport就是浏览器窗口的高度和宽度。在移动设备中，由于移动端的viewport太窄，为了更好为CSS布局服务，所以提供了两个viewport。 虚拟viewport ： visual viewport布局viewport ： layout viewport 物理像素 physical pixel物理像素也被称为设备像素，他是显示设备中一个最小的物理设备，物理像素单位。每个像素可以根据操作系统设置自己的颜色和亮度。 设备独立像素 device-independent pixel - 逻辑像素设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以程序使用的虚拟像素，比如CSS像素，然后由相关系统转换为物理像素。 CSS像素（与设备无关像素 device-independent piexl）一个抽象单位，主要使用在浏览器上，用来精确度量Web页面上点内容。一般CSS像素称为与设备无关的像素（device-independent piexl），DIPs。 屏幕密度屏幕密度是指一个设备表面上存在的像素数量，通常以每英寸有多少像素来计算（PPI） 设备像素比（device pixel ratio）设备像素比简称为dpr，定义了物理像素和设备独立像素之间的对应关系 设备像素 = 物理像素 / 设备独立像素 在JavaScript中，可以通过window.devicePiexlRatio获取当前设备的dpr。 在css中，可以通过-webkit-device-piexl-ratio、-webkit-min-device-piexl-ratio、-webkit-max-device-piexl-ratio进行媒体查询。 常见终端设备参数终端设备的参数 UI设计与前端开发适配的协作选择一种尺寸作为设计和开发的基准，定义其余尺寸的适配规则，对于特殊适配给出设计效果 淘宝手淘团队适配协作模式 视觉稿 在开发之前，UI设计师提供含有标注的PSD文件，为视觉稿。对于移动端而言，为了做到页面高清的效果，视觉稿会遵循以下两点： 选取一款手机的屏幕宽度最为基准，iphone6（375pt * 667pt） 对于retina屏幕（如dpr = 2）,为了达到高清的效果，视觉稿的画布大小会是基准的2倍，也就是说像素点个数是原来的4倍。 iphone6：dpr：2设备独立像素：375pt * 667pt (设备宽度为375pt，设备高度667pt)物理像素：750pt * 1334pt 视觉稿按照设备独立像素设计，放大两倍UI设计师常选择iPhone6作为基准设计尺寸，交付给前端的设计尺寸是按750px * 1334px为准(高度会随着内容多少而改变)。前端开发人员通过一套适配规则自动适配到其他的尺寸。 位图像素一个位图像素是栅格图像最小的数据单元，如png、jpg、gif等。每一个位图像素都包含着一些自身的显示信息，包括显示位置、颜色值、透明度等 理论上，一个位图像素对应一个物理像素，图片才能得到完美清晰的展示。在Retina屏幕下，一个位图像素对应4个物理像素。由于单个位图像素不可以在分割，所以只能就近取色，就会出现位图像素点不够，从而导致图片模糊。 rem单位 font size of the root element. rem就是相对于根元素&lt;html&gt;的font-size来做计算。而我们的方案中使用rem单位，是能轻易的根据的font-size计算出元素的盒模型大小。 em是根据父元素的font-size计算。 flexible的实质 flexible实际上就是通过JS来动态改写meta标签 源代码： var meta = document.createElement('meta'); var scale = isRetina ? 0.5 : 1; meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'initial-scale=' + scale + ' ,maximun-scale=' + scale + ' ,minimum-scale=' + scale + ' ,user-scalable=no, width=device-width'); if(document.doucmentElement.firstElementChild) { document.doucmentElement.firstElementChild.appendChild(meta); } else { var wrap = document.createElement('div'); wrap.appendChild(meta); document.write(wrap.innerHTML); } 动态改写&lt;meta&gt;标签 html标签上加上data-dpr属性，并且动态改写data-dpr的值。 html标签上加上font-size属性，并且动态改写font-size的值。 &lt;meta&gt;中initial-dpr会把dpr强制设置为给定的值。如果手动设置了dpr之后，不管设备是多少dpr，都会强制设置其dpr为你设置的值。不建议设置这个meta标签值(initial-dpr)，因为在flexible中，只有对iOS设备进行dpr的判断，对于Android系列，始终认为其dpr为1 px和rem转换目前Flexible会将设计稿分成100份，为了更好的兼容vw和vh，同时1rem单位被认定为10a。 width为750px设计稿 750px = 100vw = 100a 1rem = 10a 1rem = 75px 我们设计稿都是750px宽度，分成10份，每份为10a（10vw），也就是整个宽度为10rem，所以html对应的font-size为75px。 参考文档 A tale of two viewports - Part One A tale of two viewports - Part Two","link":"/2018/03/21/移动端适配方案/"},{"title":"前端面试集（HTML+CSS）","text":"1. 浏览器页面有哪三层构成，分别是什么，作用是什么? 构成：结构层、表示层、行为层 分别是：HTML、CSS、JavaScript 作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。 2.HTML5的优点与缺点？优点： 网络标准统一、HTML5本身是由W3C推荐出来的。 多设备、跨平台 即时更新。 提高可用性和改进用户的友好体验； 有几个新的标签，这将有助于开发人员定义重要的内容； 可以给站点带来更多的多媒体元素(视频和音频)； 可以很好的替代Flash和Silverlight； 涉及到网站的抓取和索引的时候，对于SEO很友好； 被大量应用于移动应用程序和游戏。 缺点： 安全：像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket 这样的功能很容易被黑客利用，来盗取用户的信息和资料。 完善性：许多特性各浏览器的支持程度也不一样。 技术门槛：HTML5简化开发者工作的同时代表了有许多新的属性和API需要开发者学习，像web worker、web socket、web storage 等新特性，后台甚至浏览器原理的知识，机遇的同时也是巨大的挑战 性能：某些平台上的引擎问题导致HTML5性能低下。 浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。 3.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?作用 声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。 严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 意义 doctype声明指出阅读程序应该用什么规则集来解释文档中的标记。在Web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是W3C所发布的一个文档类型定义（DTD）中包含的规则。 声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的HTML 文档。 所谓的标准模式是指，浏览器按 W3C 标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。 严格模式是浏览器根据web标准去解析页面，是一种要求严格的DTD，不允许使用任何表现层的语法，如。严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行混杂模式则是一种向后兼容的解析方法，说的透明点就是可以实现IE5.5以下版本浏览器的渲染模式。 浏览器解析时到底使用标准模式还是怪异模式，与你网页中的 DTD 声明直接相关， DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略 DTD 声明 ,将使网页进入怪异模式。 4.HTML5有哪些新特性、移除了哪些元素？ Html5 新增了 27个元素，废弃了16个元素，根据现有的标准规范，把 HTML5 的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。 结构性元素主要负责web上下文结构的定义 section：在 web 页面应用中，该元素也可以用于区域的章节描述。 header：页面主体上的头部， header 元素往往在一对 body 元素中。 footer：页面的底部（页脚），通常会标出网站的相关信息。 nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。 article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。 级块性元素主要完成web页面区域的划分，确保内容的有效分割 aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。 figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。 code：表示一段代码块。 dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。 meter：表示特定范围内的数值，可用于工资、数量、百分比等。 time：表示时间值。 progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。 video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。 audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。 details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。 datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。 menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。 command：用来处理命令按钮。 5.你做的网页在哪些流览器测试过,这些浏览器的内核分别是什么? IE: trident 内核 Firefox: gecko 内核 Safari: webkit 内核 Opera: 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核 Chrome:Blink( 基于 webkit ， Google 与 Opera Software 共同开发 ) 6. 每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面） 7.说说你对HTML5认识?（是什么,为什么）是什么：HTML5指的是包括 HTML 、 CSS 和 JavaScript 在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ， RIA ），例如： AdobeFlash 、 Microsoft Silverlight 与 Oracle JavaFX 的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 是 HTML 最新版本， 2014 年 10 月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01 和 XHTML 1.0 标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。 为什么:HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。HTML5增强了浏览器的原生功能，符合 HTML5 规范的浏览器功能将更加强大，减少了 Web 应用对插件的依赖，让用户体验更好，让开发更加方便，另外 W3C 从推出 HTML4.0 到 5.0 之间共经历了 17 年， HTML 的变化很小，这并不符合一个好产品的演进规则。 8.对WEB标准以及W3C的理解与认识? 标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和 js 脚本、结构行为表现的分离， 文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件， 容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。 9.HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些?行内元素 a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体 ( 不推荐 ) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码 ( 在引用源码的时候需要 ) dfn - 定义字段 em - 强调 font - 字体设定 ( 不推荐 ) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线 ( 不推荐 ) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 块元素 (block element) address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是 css layout 的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h3 - 大标题 h4 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持 frame 的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块 (map) object - object对象 script - 客户端脚本 空元素 在 HTML[1] 元素中，没有内容的 HTML 元素被称为空元素 br hr input img link meta 10.什么是WebGL,它有什么优点?WebGL（全写 Web Graphics Library ）是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加OpenGL ES 2.0 的一个 JavaScript 绑定， WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型了，还能创建复杂的导航和数据视觉化。显然， WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。 WebGL完美地解决了现有的 Web 交互式三维动画的两个问题： 第一，它通过HTML脚本本身实现 Web 交互式三维动画的制作，无需任何浏览器插件支持 ; 第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。通俗说WebGL中 canvas 绘图中的 3D 版本。因为原生的 WebGL 很复杂，我们经常会使用一些三方的库，如 three.js 等，这些库多数用于HTML5 游戏开发。 11.请你描述一下 cookies，sessionStorage 和 localStorage 的区别?sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的cookies会发送到服务器端。其余两个不会。Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie 。 Firefox 每个域名 cookie 限制为 50 个。 Opera 每个域名 cookie 限制为 30 个。 Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名（ name ）、值（ value ）和等号。 Opera 许 cookie 多达 4096 个字节，包括：名（ name ）、值（ value ）和等号。 Internet Explorer 允许 cookie 多达 4095 个字节，包括：名（ name ）、值（ value ）和等号。 区别： Cookie 每个域名存储量比较小（各浏览器不同，大致 4K ） 所有域名的存储量有限制（各浏览器不同，大致 4K ） 有个数限制（各浏览器不同） 会随请求发送到服务器 LocalStorage 永久存储 单个域名存储量比较大（推荐 5MB ，各浏览器不同） 总体数量无限制 SessionStorage 只在 Session 内有效 存储量更大（推荐没有限制，但是实际上各浏览器也不同） 12.说说你对HTML语义化的理解? 什么是 HTML 语义化？ 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 基本上都是围绕着几个主要的标签，像标题（ H1~H6 ）、列表（ li ）、强调（ strong em ）等等 为什么要语义化？ 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看； 用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 语义化标签 &lt;header&gt;&lt;/header&gt; &lt;footer&gt;&lt;/footer&gt; &lt;nav&gt;&lt;/nav&gt; &lt;section&gt;&lt;/section&gt; &lt;article&gt;&lt;/article&gt; SM:用来在页面中表示一套结构完整且独立的内容部分 &lt;aslde&gt;&lt;/aside&gt; SM:主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了 &lt;figure&gt;&lt;/figure&gt; SM:媒体元素，比如一些视频，图片啊等等 &lt;datalist&gt;&lt;/datalist&gt;SM:选项列表，与 input 元素配合使用，来定义 input 可能的值 &lt;details&gt;&lt;/details&gt;SM:用于描述文档或者文档某个部分的细节 ~ 默认属性为 open~ps:配合 summary 一起使用 13.link和@import的区别?&lt;link rel='stylesheet' rev='stylesheet' href='CSS文件 ' type='text/css' media='all' /> &lt;style type='text/css' media='screen'&gt; @import url('CSS文件 '); &lt;/style&gt; 两者都是外部引用CSS的方式，但是存在一定的区别： link 是 XHTML 标签，除了加载 CSS 外，还可以定义RSS 等其他事务； @import属于 CSS 范畴，只能加载 CSS 。 link 引用 CSS 时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。 link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。 14.说说你对SVG理解?SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ），用于描述二维矢量图形的一种图形格式。 SVG 是W3C(‘World Wide Web ConSortium’ 即 ‘ 国际互联网标准组织 ‘) 在 2000 年 8 月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。 SVG 严格遵从 XML 语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。 SVG 于 2003 年 1 月14 日成为 W3C 推荐标准。 特点： 任意放缩。用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。 文本独立。SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。 较小文件。总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。 超强显示效果。SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。 超级颜色控制。SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。 交互 X 和智能化。 SVG 面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。 浏览器支持Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的。 15.HTML全局属性(global attribute)有哪些?MDN: html global attribute或者W3C HTML global-attributes accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素 class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素 contenteditable: 指定元素内容是否可编辑 contextmenu: 自定义鼠标右键弹出菜单内容 data-*: 为元素增加自定义属性 dir: 设置元素文本方向 draggable: 设置元素是否可拖拽 dropzone: 设置元素拖放类型： copy, move, link hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果 id: 元素id，文档内唯一 lang: 元素内容的的语言 spellcheck: 是否启动拼写和语法检查 style: 行内css样式 tabindex: 设置元素可以获得焦点，通过tab可以导航 title: 元素相关的建议信息 translate: 元素和子孙节点内容是否需要本地化 16.说说超链接target属性的取值和作用？target这个属性指定所链接的页面在浏览器窗口中的打开方式。 它的参数值主要有： _blank ：在新浏览器窗口中打开链接文件 _parent ：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数。 _self ：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。 _top ：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。 17.data-属性的作用是什么？data-xxx为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取。 需要注意的是：data-xxx之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。并不是所有的浏览器都支持.dataset 属性，测试的浏览器中只有 Chrome 和 Opera 支持。即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。 18.介绍一下你对浏览器内核的理解？浏览器内核主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS引擎。 渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加载 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎：解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 19.常见的浏览器内核有哪些？ Trident内核： IE,MaxThon,TT,The World,360, 搜狗等。[ 又称 MSHTML] Gecko内核： Netscape6 及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核： Opera7及以上。[Opera 内核原为： Presto ，现为：Blink;] Webkit内核： Safari,Chrome 等。[ Chrome 的： Blink （ WebKit 的分支） ] 20.iframe有那些缺点？ iframe会阻塞主页面的 Onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO; iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。 21.Label的作用是什么，是怎么用的？label标签来定义表单控制间的关系 , 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 &lt;label for='Name'>Number:&lt;/label> &lt;input type=“ text “ name='Name' id='Name'/> &lt;label>Date:&lt;input type='text' name='B'/>&lt;/label> 22.如何实现浏览器内多个标签页之间的通信?WebSocket、 SharedWorker，也可以调用localstorge、 cookies 等本地存储方式；localstorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks： Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常； 23.如何在页面上实现一个圆形的可点击区域？ map+area(锚点图) 或者 svg border-radius 纯 js 实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 24.title与h3的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题， H1 则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时： 会重读，而 &lt;B&gt;是展示强调内容。 i内容展示为斜体， em 表示强调的文本； Physical Style Elements – 自然样式标签b, i, u, s, pre Semantic Style Elements – 语义样式标签strong, em, ins, del, code应该准确使用语义样式标签, 但不能滥用 , 如果不能确定时首选使用自然样式标签。 25.实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？&lt;div style='height:1px;overflow:hidden;background:red'>&lt;/div> 26.HTML5标签的作用?(用途) 使Web页面的内容更加有序和规范 使搜索引擎更加容易按照HTML5规则识别出有效的内容 使Web页面更接近于一种数据字段和表 27.简述一下src与href的区别？src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。 src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js脚本 ， img图片和 frame 等元素。 &lt;script src ='js.js'>&lt;/script> 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加&lt;link href='common.css' rel='stylesheet'/&gt;，那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用@import 方式。 28.谈谈你对canvas的理解？canvas是HTML5中新增一个HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。标记和 SVG以及 VML 之间的一个重要的不同是，有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。SVG 绘图很容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。 29.WebSocket与消息推送？B/S架构的系统多使用HTTP协议 HTTP协议的特点： 1. 无状态协议 2. 用于通过 Internet 发送请求消息和响应消息 3. 使用端口接收和发送消息，默认为80端口 底层通信还是使用Socket完成。 HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（ F5 已坏）一些变相的解决办法：双向通信与消息推送轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。优点：后端程序编写比较容易。缺点：请求中有大半是无用，浪费带宽和服务器资源。实例：适于小型应用。长轮询：客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。优点：在无消息的情况下不会频繁的请求，耗费资小。缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ，实例：WebQQ、 Hi 网页版、 Facebook IM 。长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断地往客户端输入数据。优点：消息即时到达，不发无用请求；管理起来也相对便。缺点：服务器维护一个长连接会增加开销。实例：Gmail聊天Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。优点：实现真正的即时通信，而不是伪即时。缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。实例：网络互动游戏。Websocket:WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。特点:a、事件驱动b、异步c、使用 ws 或者 wss 协议的客户端 socketd、能够实现真正意义上的推送功能缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别。 30.img的title和alt有什么区别？ alt 用于图片无法加载时显示 title 为该属性提供信息，通常当鼠标滑动到元素上的时候显示 31.表单的基本组成部分有哪些，表单的主要用途是什么？组成：表单标签、表单域、表单按钮 表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法。 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。 表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。 32.表单提交中Get和Post方式的区别？ get 是从服务器上获取数据， post 是向服务器传送数据。 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。 对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为100KB 。 get 安全性非常低， post 安全性较高。 33.HTML5 有哪些新增的表单元素？HTML5 新增了很多表单元素让开发者构建更优秀的 Web 应用程序。 datalist datetime output keygen date month week time color number range email Url 34.HTML5 废弃了哪些 HTML4 标签？HTML5 废弃了一些过时的，不合理的HTML 标签： frame frameset noframe applet big center basefront 35.HTML5 标准提供了哪些新的 API？HTML5 提供的应用程序 API 主要有： Media API Text Track API Application Cache API User Interaction Data Transfer API Command API Constraint Validation API History API 36.HTML5 存储类型有什么区别？HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。 HTML5 提供了下面两种本地存储方案： localStorage 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 sessionStorage 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 37.HTML5 应用程序缓存和浏览器缓存有什么区别？应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下： &lt;!doctype html> &lt;html manifest=”example.appcache”> &lt;!-- ... --> &lt;/html> 与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。 38.HTML5 Canvas 元素有什么用？Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作 &lt;canvas id=” canvas1 ″ width= ” 300 ″ height= ” 100 ″ > &lt;/canvas> 39.除了 audio 和 video，HTML5 还有哪些媒体标签？ HTML5 对于多媒体提供了强有力的支持，除了 audio 和 video 标签外，还支持以下标签： 标签定义嵌入的内容，比如插件。&lt;embed type=” video/quicktime ” src= ” Fishing.mov ” &gt; 对于定义多个数据源很有用。` &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt; * &lt;track&gt; 标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt; 据源很有用。标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 ### 40.HTML5 中如何嵌入视频？ &gt;和音频类似，HTML5 支持 MP4 、 WebM 和 Ogg 格式的视频，下面是简单示例： &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; Your browser does’ nt support video embedding feature. ### 4.HTML5 中如何嵌入音频？ &gt;HTML5 支持 MP3 、 Wav 和 Ogg 格式的音频，下面是在网页中嵌入音频的简单示例： &lt;source src=” jamshed.mp3 ″ type= ” audio/mpeg ” &gt; Your browser does’ nt support audio embedding feature. ### 42 .新的 HTML5 文档类型和字符集是？ &gt;HTML5 文档类型很简单： &lt;!doctype html&gt; ` 43.解释一下CSS的盒子模型？ 标准的css盒子模型：宽度=内容的宽度+边框的宽度+加上内边具的宽度 网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。 这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 盒子模型也有人称为框模型，HTML中的多数元素都会在浏览器中生成一个矩形的区域，每个区域包含四个组成部分，从外向内依次是：外边距（Margin）、边框（Border）、内边距（Padding）和内容（Content），其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型，加上了doctype声明，让所有浏览器都会采用标准 w3c 盒子模型去解释你的盒子。 44. 请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素 45.请你说说CSS有什么特殊性?（优先级、计算特殊值）优先级 同类型，同级别的样式后者先于前者 ID &gt; 类样式 &gt; 标签 &gt; 内联&gt;ID选择器&gt;伪类&gt;属性选择器&gt;类选择器&gt;标签选择器&gt;通用选择器()&gt;继承的样式 具体 &gt; 泛化的，特殊性即css优先级 近的 &gt; 远的 (内嵌样式 &gt; 内部样式表 &gt; 外联样式表) 内嵌样式：内嵌在元素中，span 内部样式表：在页面中的样式，写在中的样式外联样式表：单独存在一个css文件中，通过link引入或import导入的样式 !important 权重最高，比 inline style 还要高 计算特殊性值 important &gt; 内嵌 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符 权重、特殊性计算法：CSS样式选择器分为4个等级，a、b、c、d 如果样式是行内样式（通过Style=“”定义），那么a=1，1,0,0,0 b为ID选择器的总数 0,1,0,0 c为属性选择器，伪类选择器和class类选择器的数量。0,0,1,0 d为标签、伪元素选择器的数量 0,0,0,1 !important 权重最高，比 inline style 还要高比如结果为：1093比1100，按位比较，从左到右，只要一位高于则立即胜出，否则继续比较。 46.要动态改变层中内容可以使用的方法？innerHTML，innerText","link":"/2017/09/15/interview-HTML-CSS/"}],"tags":[{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"ngSanitize","slug":"ngSanitize","link":"/tags/ngSanitize/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"button","slug":"button","link":"/tags/button/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","link":"/tags/CSS3/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"图片","slug":"图片","link":"/tags/图片/"},{"name":"懒加载， 原生JS","slug":"懒加载，-原生JS","link":"/tags/懒加载，-原生JS/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"text-overflow","slug":"text-overflow","link":"/tags/text-overflow/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"util","slug":"util","link":"/tags/util/"},{"name":"阿里字体","slug":"阿里字体","link":"/tags/阿里字体/"}],"categories":[{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"React study","slug":"React-study","link":"/categories/React-study/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"Web / H5","slug":"Web-H5","link":"/categories/Web-H5/"},{"name":"Web H5","slug":"Web-H5","link":"/categories/Web-H5/"},{"name":"面试","slug":"面试","link":"/categories/面试/"},{"name":"前端","slug":"面试/前端","link":"/categories/面试/前端/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"html","slug":"css/html","link":"/categories/css/html/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"util","slug":"Javascript/util","link":"/categories/Javascript/util/"},{"name":"canvas","slug":"Javascript/canvas","link":"/categories/Javascript/canvas/"},{"name":"study","slug":"React/study","link":"/categories/React/study/"},{"name":"SVG","slug":"CSS/SVG","link":"/categories/CSS/SVG/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"SCSS","slug":"CSS/SCSS","link":"/categories/CSS/SCSS/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"阿里字体","slug":"Javascript/阿里字体","link":"/categories/Javascript/阿里字体/"}]}