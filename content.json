{"pages":[{"title":"映像","text":"","link":"/gallery/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"},{"title":"音乐播放器","text":"","link":"/music/index.html"},{"title":"我们","text":"","link":"/ours/index.html"},{"title":"黑客帝国","text":"","link":"/matrix/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"时间轴","text":"","link":"/timeline/index.html"},{"title":"VIP","text":"","link":"/vip/index.html"}],"posts":[{"title":"React-JSX","text":"JSX语法 JSX 既不是字符串也不是HTML，是JavaScript的语法扩展，将被解析成JavaScript的一个对象。JSX用于生成React的“元素”。JSX中可以嵌入js表达式，用12345678910111213141516171819&lt;!-- more --&gt;```javascriptfunction formatName(user) { return user.firstName + &apos; &apos; + user.lastName; }const user = { firstName: &apos;Harper&apos;, lastName: &apos;Perez&apos;}const element = ( &lt;h1&gt;Hello, {formatName(user)} !&lt;/h1&gt;)ReactDOM.render( element, document.getElementById(&apos;root&apos;)) JSX指定属性 使用引号将字符串文字指定为属性值 1const element = &lt;div tabIndex=\"0\"&gt;&lt;/div&gt; 使用花括号12```javascriptconst element = &lt;img src={user.avtarurl} /&gt; JXS包含子标签 JSX可以包含子标签 JSX最外层只能包含一个标签，父标签内可以嵌套任意的子标签 JSX 标签内的属性命名约定使用 123456789101112```javascriptconst element = ( &lt;div className=&quot;demo&quot;&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you!&lt;/h2&gt; &lt;/div&gt;)const elemtent = ( &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;) JSX转换Bebel将JSX转换编译成1234567```javascriptconst element = ( &lt;h1 className=&quot;greeting&quot;&gt; Hello, World! &lt;/h1&gt;) 12345const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, World!') 以上两种方式是等价的，最后都会转换成React Elements，这些对象组成页面的DOM并且保持更新。 解析为react Elements 1234567const element = { type: 'h1', props: { className: 'greeting', children: 'Hello, World!' }}","link":"/2017/09/15/React-JSX/"},{"title":"BFC块级格式化上下文","text":"BFC（Block Formating Context） 块级格式化上下文：一个独立的渲染区域，只有 Block-level box 参与，它内部规定了 Block-level box 如何布局，并且与这个区域外部毫不相干。 BFC是Web页面的可视化CSS渲染的一部分，并且有自身的一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用。 CSS有三种基本定位机制 普通流(或称常规流)：CSS默认的定位方式，触发方式包括为 position: static | relative ，且 float:none 浮动：浮动脱离普通流，可以左右移动，直到它的外边框边缘碰到包含框或另一个浮动框的边缘，触发方式基本就是 float:left | top等。可以通过 position: relative 设置其 top、left 等属性(先进行浮动，在进行位置偏移)。 绝对定位：盒子脱离普通流，不影响普通流上其他元素的布局，设置float无效。 BFC 概念BFC即Block Formatting Content（块级格式上下文），它属于上述定位方案的普通流。具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。 BFC布局规则具有 BFC 特性的元素可以看成是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。 内部Box会在垂直方向上一个接一个的放置 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会合并 每个元素的margin box的左边，与包含块border box的左边相接触 BFC的区域不会与float box重叠 BFC是一个独立的容器，里面的子元素不会影响到外面的元素，反之亦然 计算BFC的高度的时候，浮动元素也参与计算 生成BFC 根元素 float属性不为none 绝对定位元素（absolute, fixed） display为inline-block,table-cell,table-caption,flex, grid overflow不为visible flex grid BFC作用 自适应两栏布局 可以阻止元素被浮动元素覆盖 1234567891011121314151617181920212223&lt;style type=\"style/css\"&gt;.container { position: relative;}.aside { width: 100px; height: 150px; float: left; background: #f66;}.main { height: 200px; background: #fcc; overflow: hidden;}&lt;/style&gt;&lt;body&gt; &lt;div class=\"container\"&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; main 节点如果不设置为 BFC ，那么根据规则每个元素的 margin box 的左边，与包含块 border box 的左边相接触, main 将会被 aside 覆盖。通过 overflow:hidden 设置为 BFC ， BFC 区域不会和 float box 重叠。 可以包含浮动元素——清除内部浮动 包含浮动元素的父元素，设置 overflow: auto 创建一个新的BFC来包含这个浮动。父元素现在变成布局中的迷你布局，任何子元素都会被包含进去。 面试题：为什会内容环绕呢，而不是跟浮动元素重合呢？《CSS权威指南》中指出，浮动的目的，最初只能用于图像，目的就是为了允许其他内容（如文本）“围绕”该图像。而后来的CSS允许浮动任何元素。 分属于不同的BFC时可以阻止margin重叠外边距塌陷: 创建新的BFC避免两个相邻&lt;div&gt;之间的外边距合并 外边距塌陷 外边距折叠：块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者。 注意浮动元素和绝对定位元素的外边距不会折叠。 外边距折叠的三种基本情况1. 相邻元素之间毗邻的两个元素之间的外边距会折叠（除非后一个元素需要清除之前的浮动）。 2. 父元素与其第一个或最后一个子元素之间如果在父元素与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的margin-top分开；或者在父元素与其最后一个子元素之间不存在边框、内边距、行内内容、height、min-height、max-height将两者的margin-bottom分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。 3.空的块级元素如果一个块级元素中不包含任何内容，并且在其margin-top与margin-bottom 之间没有边框、内边距、行内内容、height、min-height将两者分开，则该元素的上下外边距会折叠。 一些需要注意的地方： 上述情况的组合会产生更复杂的外边距折叠。 即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第* 一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。 MDN: BFC 块级格式化上下文Understanding CSS Layout And The Block Formatting Context","link":"/2019/04/09/BFC块级格式化上下文/"},{"title":"ES6模块和CommonJS模块的区别","text":"ES6 模块与 CommonJS 模块的差异 CommonJS基本语法 暴露模块：module.exports = value或exports.xxx = value 引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径 123456789101112// example.jsvar x = 5;var addX = function (value) { return value + x;};module.exports.x = x;module.exports.addX = addX;// mian.jsvar example = require('./example.js'); //如果参数字符串以“./”开头，则表示加载的是一个位于相对路径console.log(example.x); // 5console.log(example.addX(1)); // 6 ES6ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 123456789101112/** 定义模块 math.js **/var basicNum = 0;var add = function (a, b) { return a + b;};export { basicNum, add };/** 引用模块 **/import { basicNum, add } from './math';function test(ele) { ele.textContent = add(99 + basicNum);} 区别它们有两个重大差异： ① CommonJS 模块输出的是一个值的拷贝， ES6 模块输出的是值的引用。 ② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子: 12345678910// lib.jsexport let counter = 3;export function incCounter() { counter++;}// main.jsimport { counter, incCounter } from './lib';console.log(counter); // 3incCounter();console.log(counter); // 4 ES6 模块的运行机制与 CommonJS 不一样。 ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 前端模块化详解","link":"/2019/04/12/ES6模块和CommonJS模块的区别/"},{"title":"MySQL安装教程","text":"1. 下载安装1.1 下载MySQL8.0 For Windows zip包下载地址：MySQL8.0 For Window，进入页面后可以不登录。后点击底部No thanks, just start my download.即可开始下载。或直接下载：https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.11-winx64.zip 1.2 安装解压zip包到安装目录 配置文件：在Windows系统中，配置文件默认是安装目录下的 my.ini 文件（或my-default.ini），部分配置需要在初始安装时配置，大部分也可以在安装完成后进行更改。当然，极端情况下，所有的都是可以更改的。 我们发现解压后的目录并没有my.ini文件，没关系可以自行创建。在安装根目录下添加 my.ini，比如我这里是：C:\\Program Files\\MySQL\\my.ini，写入基本配置： 123456789101112131415161718192021222324[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=C:\\Program Files\\MySQL# 设置mysql数据库的数据的存放目录datadir=E:\\database\\MySQL\\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 注意，里面的 basedir 是本地的安装目录，datadir 是我数据库数据文件要存放的位置，各项配置需要根据自己的环境进行配置。查看所有的配置项，可参考：https://dev.mysql.com/doc/refman/8.0/en/mysqld-option-tables.html 2 初始化数据库在MySQL安装目录的 bin 目录下执行命令： mysqld --initialize --console 执行完成后，会打印 root 用户的初始默认密码，比如： 123456C:\\Users\\Administrator&gt;cd C:\\Program Files\\MySQL\\binC:\\Program Files\\MySQL\\bin&gt;mysqld --initialize --console2018-04-28T15:57:17.087519Z 0 [System] [MY-013169] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server in progress as process 49842018-04-28T15:57:24.859249Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E2018-04-28T15:57:27.106660Z 0 [System] [MY-013170] [Server] C:\\Program Files\\MySQL\\bin\\mysqld.exe (mysqld 8.0.11) initializing of server has completedC:\\Program Files\\MySQL\\bin&gt; 注意！执行输出结果里面有一段： [MY-010454] [Server] A temporary password is generated for root@localhost: rI5rvf5x5G,E``` 其中```root@localhost:```后面的```rI5rvf5x5G,E```就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。12345# 3 安装数据库在MySQL安装目录的 bin 目录下执行命令（以管理员身份打开cmd命令行，或者在安装目录Shift+右键“在此处打开命令行窗口”）：&gt; ```mysqld --install [服务名] 后面的服务名可以不写，默认的名字为 mysql。 安装完成之后，就可以通过命令start mysql```启动MySQL的服务了。1234567示例：```cmdC:\\Program Files\\MySQL\\bin&gt;mysqld --installService successfully installed.C:\\Program Files\\MySQL\\bin&gt;net start mysqlMySQL 服务正在启动 ..MySQL 服务已经启动成功。 4 修改密码在MySQL安装目录的 bin 目录下执行命令： -u root -p```12345这时候会提示输入密码，记住了上面第1.3步安装时的密码，填入即可登录成功，进入MySQL命令模式。修改密码:&gt; ```ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;; 12[mysqld]default_authentication_plugin=mysql_native_password 12345678910111213C:\\Program Files\\MySQL\\bin&gt;mysql -u root -pEnter password: ************Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 8Server version: 8.0.11Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码';Query OK, 0 rows affected (0.06 sec)mysql&gt;","link":"/2018/05/29/MySQL安装教程/"},{"title":"Loadsh库模块化引入","text":"loadsh提供模块按需加载 loadsh本身提供模块化引入，可按需引入 1234567// import { debounce } from 'loadsh'import { throttle } from 'loadsh'// 按需引入import { debounce } from 'loadsh/debounce'import { throttle } from 'loadsh/throttle' webpack plugin 配置 通过webpack配置，按需加载所需要的模块 loadsh-webpack-plugin babel-plugin-loadsh 结合使用，将全路径引用的loadsh自动转变为模块化按需引用 12345678910111213141516// @/util/loadsh.js 统一引入需要的loadsh方法import _ from 'loadsh'export default { cloneDeep: _.cloneDeep, debounce: _.debounce, throttle: _.throttle, isEmpty: _.isEmpty}// 注入全局 main.jsimport _ from '@/util/loadsh.js'Vue.prototype.$_ = _// 组件使用this.$_.debounce()","link":"/2019/04/09/Loadsh库模块化引入/"},{"title":"Uncaught TypeError: angular.module(...).provider(...).info is not a function","text":"package.json中angular版本与ngSanitize版本不一致导致错误：Uncaught TypeError: angular.module(…).provider(…).info is not a function #github issue 上问题解答 尬，angular版本必须要与ngSanitize版本一致！ We do not support running core AngularJS that are at different versions. Can you explain why you would upgrade angular.js to 1.6.x but leave angular-sanitize.js at 1.5.x?","link":"/2017/09/14/Uncaught-TypeError-angular-module-provider-info-is-not-a-function/"},{"title":"URL操作处理","text":"URL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * URL模块 * @param {[type]} require [description] * @param {[type]} exports [description] * @param {[type]} module [description] * @return {[type]} [description] */define('url', function (require, exports, module) { var _cacheThisModule_; module.exports = { /** * 设置hash * @param name */ setHash: function (name) { setTimeout(function () { location.hash = name; }, 0); }, /** * 获取当前url中的hash值 * @param url * @return String */ getHash: function (url) { var u = url || location.hash; return u ? u.replace(/.*#/, \"\") : \"\"; }, /* * 根据hash获取对应的模块名 */ getHashModelName: function () { var hash = this.getHash(); return (hash ? hash.split(\"&amp;\")[0].split(\"=\")[0] : []); }, /* * 从hash中获取action */ getHashActionName: function () { var hash = this.getHash(); if (hash == \"\")return \"\"; return (hash ? hash.split(\"&amp;\") : [])[0].split(\"=\")[1]; }, /* * 从hash中获取name对应的值 */ getHashParam: function (name) { var result = this.getHash().match(new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\")); return result != null ? result[2] : \"\"; }, /* * 从URL中获取参数对应的值 */ getUrlParam: function (name, url) { //参数：变量名，url为空则表从当前页面的url中取 var u = arguments[1] || window.location.search, reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\", 'i'), r = u.substr(u.indexOf(\"\\?\") + 1).match(reg); return r != null ? r[2] : \"\"; }, /* * 获取所有HASH的参数，剔除model. */ getParams: function () { var param = [], hash = this.getHash(); paramArr = hash ? hash.split(\"&amp;\") : []; for (var i = 1, l = paramArr.length; i &lt; l; i++) { param.push(paramArr[i]); } return param; }, decodeUrl: function (url) { url = decodeURIComponent(url); var urlObj = this.parseUrl(url), decodedParam = []; $.each(urlObj.params, function (key, value) { value = decodeURIComponent(value); decodedParam.push(key + \"=\" + value); }); var urlPrefix = url.split(\"?\")[0]; return urlPrefix + \"?\" + decodedParam.join(\"&amp;\"); }, parseUrl: function (url) { var a = document.createElement('a'); a.href = url; return { source: url, protocol: a.protocol.replace(':', ''), host: a.hostname, port: a.port, query: a.search, params: (function () { var ret = {}, seg = a.search.replace(/^\\?/, '').split('&amp;'), len = seg.length, i = 0, s; for (; i &lt; len; i++) { if (!seg[i]) { continue; } s = seg[i].split('='); ret[s[0]] = s[1]; } return ret; })(), file: (a.pathname.match(/([^\\/?#]+)$/i) || [, ''])[1], hash: a.hash.replace('#', ''), path: a.pathname.replace(/^([^\\/])/, '/$1'), relative: (a.href.match(/tps?:\\/\\/[^\\/]+(.+)/) || [, ''])[1], segments: a.pathname.replace(/^\\//, '').split('/') }; }, replaceParam: function (param, value, url, forceReplace) { url = url || location.href; var reg = new RegExp(\"([\\\\?&amp;]\" + param + \"=)[^&amp;#]*\"); if (!url.match(reg)) { return (url.indexOf(\"?\") == -1) ? (url + \"?\" + param + \"=\" + value) : (url + \"&amp;\" + param + \"=\" + value); } if (forceReplace) { return url.replace(reg, \"$1\" + value); } return url; } };});","link":"/2018/05/30/URL操作处理/"},{"title":"Vue双向绑定","text":"双向绑定MVVM：数据变化更新试图，视图变化更新数据。 Model View ViewModel 双向绑定实现 vue: 数据劫持vue数据实现双向绑定是通过数据劫持结合发布者-订阅者模式实现的。 angular: 脏检查机制当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。 vue实现实现数据的双向绑定，首先要对数据进行劫持监听，设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 1. 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动，就通知订阅者。123456789101112131415161718192021222324252627282930function defineReactive(data, key, value) { observe(val); // 递归遍历所有子属性 var dep = new Dep(); Object.defineProperty(data, key, { enumerable: true, configurable: true, set: function(newVal) { if( val === newVal ) { return; } value = newVal; dep.notify(); // 如果数据变化，通知所有订阅者 }, get: function() { if(Dep.target) { // 判断是否需要添加订阅者 dep.addSub(Dep.target); // 添加订阅者 } return value; } })}function observe(data) { if(!data || typeof data !== 'object') { return; } Object.keys(data).forEach(key =&gt; { defineReactive(data, key, data[key]); })} 2. 实现一个消息订阅器Dep，主要负责收集订阅者，然后在属性变化的时候执行对应订阅者的更新函数。 创建一个可以容纳订阅者的消息订阅起Dep。 1234567891011121314function Dep() { this.subs = [];}Dep.property.addSub = function(sub) { this.subs.push(sub);}Dep.property.notify = function() { this.subs.forEach(sub =&gt; { sub.update(); })}Dep.target = null; 我们将订阅器Dep添加一个订阅者设计在getter里面，这是为了让Watcher初始化进行触发，因此需要判断是否要添加订阅者，至于具体设计方案，下文会详细说明的。在setter函数里面，如果数据变化，就会去通知所有订阅者，订阅者们就会去执行对应的更新的函数。到此为止，一个比较完整Observer已经实现了，接下来我们开始设计Watcher。 3. 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。 监听器Observer是在get函数执行了添加订阅者Watcher的操作，所以在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作。注意只在订阅者Watcher初始化的时候才需要添加订阅者。 1234567891011121314151617181920212223242526function Watcher(vm, exp, cb) { this.cb = cb; this.vm = vm; this.exp = exp; this.value = this.get(); // 将自己添加到订阅器的操作} Watcher.prototype = { update: function() { this.run(); }, run: function() { var value = this.vm.data[this.exp]; var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); } }, get: function() { Dep.target = this; // 缓存自己 var value = this.vm.data[this.exp] // 强制执行监听器里的get函数 Dep.target = null; // 释放自己 return value; }}; 关联Wathcher和Observer到此为止，简单版的Watcher设计完毕，这时候我们只要将Observer和Watcher关联起来，就可以实现一个简单的双向绑定数据了。 123&lt;body&gt; &lt;h1 id=\"name\"&gt;{{name}}&lt;/h1&gt;&lt;/body&gt; 12345678910// Observer和Watcher关联起来function SelfVue (data, el, exp) { this.data = data; observe(data); el.innerHTML = this.data[exp]; // 初始化模板数据的值 new Watcher(this, exp, function (value) { el.innerHTML = value; }); return this;} 123456789var ele = document.querySelector('#name');var selfVue = new SelfVue({ name: 'hello world'}, ele, 'name');window.setTimeout(function () { console.log('name值改变了'); selfVue.data.name = 'canfoo';}, 2000); 4. 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。数据劫持Object.defineProperty()方法实现数据劫持，Object.defineProperty()用来控制对象属性，比如读写权限、是否可枚举、描述属性get和set等。","link":"/2019/04/09/Vue双向绑定/"},{"title":"cache-control缓存","text":"Cache-Control指定了请求和响应遵循的缓存机制。好的缓存机制可以减少对网络带宽的占用，可以提高访问速度，提高用户的体验，还可以减轻服务器的负担。 Cache-Control值类型(1) 请求Request： no-cache 不要读取缓存中的文件，要求向WEB服务器重新请求 no-store 请求和响应都禁止被缓存 max-age 表示当访问此网页后的max-age秒内再次访问不会去服务器请求，其功能与Expires类似，只是Expires是根据某个特定日期值做比较。一但缓存者自身的时间不准确.则结果可能就是错误的，而max-age显然无此问题。 Max-age的优先级也是高于Expires的。 max-stale 允许读取过期时间必须小于max-stale值的缓存对象。 min-fresh 接受其max-age生命期大于其当前时间跟min-fresh值之和的缓存对象only-if-cached告知缓存者,我希望内容来自缓存，我并不关心被缓存响应,是否是新鲜的. no-transform 告知代理,不要更改媒体类型,比如jpg,被你改成png. (2) 响应Response： public 数据内容皆被储存起来，就连有密码保护的网页也储存，安全性很低 private 数据内容只能被储存到私有的cache，仅对某个用户有效，不能共享 no-cache 可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端 no-store 请求和响应都禁止被缓存 max-age 本响应包含的对象的过期时间 Must-revalidate 如果缓存过期了，会再次和原来的服务器确定是否为最新数据，而不是和中间的proxy max-stale 允许读取过期时间必须小于max-stale 值的缓存对象。 proxy-revalidate与Must-revalidate类似，区别在于：proxy-revalidate要排除掉用户代理的缓存的。即其规则并不应用于用户代理的本地缓存上。-maxage 与max-age的唯一区别是,s-maxage仅仅应用于共享缓存.而不应用于用户代理的本地缓存等针对单用户的缓存. 另外,s-maxage的优先级要高于max-age. no-transform 告知代理,不要更改媒体类型,比如jpg,被你改成png.","link":"/2019/04/09/cache-control缓存/"},{"title":"cookie操作","text":"cookie处理操作 1234567891011121314151617181920212223242526272829303132333435363738394041define(\"cookie\",function(require,exports,module){ var _cacheThisModule_; exports.get = getCookie; exports.set = setCookie; exports.del = delCookie; function getCookie(name) { //读取COOKIE var reg = new RegExp(\"(^| )\" + name + \"(?:=([^;]*))?(;|$)\"), val = document.cookie.match(reg); if(!val || !val[2]){return \"\";} var res = val[2]; try{ if(/(%[0-9A-F]{2}){2,}/.test(res)){//utf8编码 return decodeURIComponent(res); }else{//unicode编码 return unescape(res); } }catch(e){ return unescape(res); } } function setCookie(name, value, expires, path, domain, secure) { //写入COOKIES var exp = new Date(), expires = arguments[2] || null, path = arguments[3] || \"/\", domain = arguments[4] || null, secure = arguments[5] || false; expires ? exp.setMinutes(exp.getMinutes() + parseInt(expires)) : \"\"; document.cookie = name + '=' + escape(value) + ( expires ? ';expires=' + exp.toGMTString() : '') + ( path ? ';path=' + path : '') + ( domain ? ';domain=' + domain : '') + ( secure ? ';secure' : ''); } function delCookie(name, path, domain, secure) { //删除cookie var value = getCookie(name); if(value != null) { var exp = new Date(); exp.setMinutes(exp.getMinutes() - 1000); path = path || \"/\"; document.cookie = name + '=;expires=' + exp.toGMTString() + ( path ? ';path=' + path : '') + ( domain ? ';domain=' + domain : '') + ( secure ? ';secure' : ''); } }});","link":"/2018/05/30/cookie操作/"},{"title":"CSS中的content和attr","text":"content和attr表达式，它们能在你的页面下面悄悄的使用CSS来生成内容，下面让我们看看attr和content如何相互配合产生神奇效果的。 基本content用法 content属性能让程序员使用CSS往页面元素里填写内容： 123.myDiv:after { content: \"我是一个使用*content*属性生产的静态文字\"; } 请注意，如果想让伪元素relative```。1234567891011### content和attr配合使用如果你不想把content内容在CSS里写死，那你可以使用attr表达式来从页面元素中动态的获取内容：&gt; attr属性通常和自定义属性data-配合使用，因为传统的其它属性虽然也能存值，但通常不适合存放表达性文字。```css/* &lt;div data-line=&quot;1&quot;&gt;&lt;/div&gt; */div[data-line]:after { content: attr(data-line); /* 属性名称上不要加引号！ */} content里的字符串连接操作 content内容支持字符串的拼接 这种字符串连接很像常规编程语言了： 1234/* &lt;div data-line=\"1\"&gt;&lt;/div&gt; */div[data-line]:after { content: \"[line \" attr(data-line) \"]\";} 还需要用JavaScript里拼装字符串吗？CSS3里就能完成这些，是不是感觉CSS3可以部分的替代Javascript了！attr的动态生成页面内容的能力着实是一件让人兴奋的事情。你实际上可以用它配合content对页面的很多其他元素和属性进行操作。","link":"/2017/09/15/css-content-attr/"},{"title":"按钮点击水波效果","text":"Material Design设计按钮点击效果比较酷炫，每次点击按钮都会产生一次水波涟漪的效果。 可以css和canvas来实现这种效果。 css实现伪类（pseudo-class）和伪元素(peseudo-element) 伪类 1&gt; * ```:after 链接定义样式 : 鼠标滑过元素上方时的展现效果1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; * ```:active``` : 鼠标单击元素时展现效果&gt; * ```:visited``` : 已经单击过的链接&gt; * ```:link``` : 未访问、未滑过、未点击过的链接标签的样式#### 段落样式&gt; * ```:first-letter``` : 首字母&gt; * ```:first-line``` : 首行#### 设置元素&gt; button元素在没有点击或者鼠标滑过时设置按钮样式,同时设置hover和active的样式效果```css.button { text-decoration:none; user-select:none; position: relative; display: block; margin: 100px auto; width:120px; height:50px; line-height:50px; text-align:center; border-radius:25px; border: none; color:#fff; font-size:16px; cursor:pointer; background-color: #ff8300; box-shadow: 0 3px 9px 0 rgba(255, 131, 0, 0.35); overflow: hidden;}.button:hover { transform: translateY(-2px); box-shadow: 0 5px 13px 0 rgba(255, 131, 0, 0.59);}.button:active { box-shadow: 0 3px 9px 0 rgba(255, 131, 0, 0.35); color: #ffca8c; background-color: #f07b00; transform: translateY(0);} 添加水波效果 参考","link":"/2017/09/25/css-button-click/"},{"title":"CSS实现元素水平垂直居中","text":"在前端开发过程中，盒子居中是常常用到的。其中 ，居中又可以分为水平居中和垂直居中。块级元素的水平居中比较容易，直接设置元素的0 auto```就可以实现，垂直居中相对来说是比较复杂一些的。1234567891011121314&lt;!-- more --&gt;## 高度位置，使用绝对定位```css.parentElem { position: relative;}.childElem { position: absolute; top: 50%; transform: translateY(-50%);} 父容器高度已知 且只有一个元素，只要使用相对定位即可 123456789.parentElem { height: 200px;}.childElem { position: relative; top: 50%; transform: translateY(-50%);} 水平居中方案行内元素1text-aligin: center; 块级元素，宽度固定1margin: 0 auto; 块级元素，宽度不定1margin: 0 auto; vertical-align 垂直对齐 元素默认垂直对齐方式为基准对齐（baseline） 继承性： 不继承 适用于行内元素和单元格（table-cell）元素 语法 : 基准线123456789&gt; * ```middle``` : 中部对齐&gt; * ```top``` : 顶端对齐&gt; * ```bottom``` : 底端对齐&gt; * ```text-top``` : 与文本顶部对齐&gt; * ```text-bottom``` : 与文本底部对齐&gt; * ```sub``` : 下标&gt; * ```super``` : 上标&gt; * ```&lt;百分比&gt;```，```&lt;长度&gt;``` : 可为负数&gt; * ```inherit 图片本身没有基线，则将其底部与父元素的基线对齐。 参考：垂直对齐：vertical-align属性","link":"/2017/09/13/css-layout/"},{"title":"JS原生图片懒加载","text":"图片懒加载懒加载是前端优化的一种技术，旨在用户进入页面后，当滚动页面将要到达图片位置时才加载图片。加快页面加载速度，极大的提升了用户体验，也避免了用户进入页面之后就发送n多个图片请求，服务器吃不消啊！ 实现原理先将图片的12345678910111213141. 页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片2. 用户滚动页面至图片位置时，img元素获取到真正的路径后，开始发送请求加载图片&lt;!-- more --&gt;### JS中位置相关&gt; * ```screenLeft/screenX```: 窗口相对于屏幕左边的位置 &gt; * ```screenTop/screenY```: 窗口相对于屏幕上边的位置**表示的是从屏幕左边和上边到window对象表示的可见区域的距离**。```javascript//FF中支持 screenX 和 screenYlet leftPos = (typeof window.screenLeft == &apos;Number&apos;) ? window.screenLeft : window.screenX;let TopPos = (typeof window.screenTop == &apos;Number&apos;) ? window.screenTop : window.screenY; 若window对象是最外层对象，而且浏览器窗口贴紧屏幕上方，则 为 01234567891011121314151617181920&gt; * ```clientWidth/clientHeight``` : 页面视口大小信息（ALL，注意获取方式）&gt; * ```innerWidth/innerHeight``` : 获取页面视口大小（页面尺寸）,页面视图容器大小&gt; * ```outerWidth/outerHeight``` : 获取浏览器窗口本身的大小（IE9+、Safari、FF）```javascriptlet pageWidth = window.innerWidth;let pageHeight = window.innerHeight;if( typeof pageWidth != &apos;Number&apos;){ if(document.compatMode == &apos;CSS!Compat&apos;){ //标准模式 pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; } else { //怪异模式（混杂模式） pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; }} 懒加载实现12345678910111213141516171819var imgCurrent = 4;//初始化页面加载图片个数var imgCount = 40;//总图片数var height = document.body.clientHeight || document.documentElement.clientHeight;var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;var clientHeight = Math.min(document.documentElement.scrollHeight, document.documentElement.clientHeight);var img = document.getElementsByTagName('img');window.onscroll = null;window.onscroll = () =&gt; { //图片懒加载 for (var i = imgCurrent; i &lt; imgCount; i++) { if (img[i].offsetTop &lt; clientHeight + scrollTop) { img[i].src = img[i].getAttribute('data-src'); img[i].style.opacity = 1; imgCurrent = i + 1; console.log('图片加载[' + i + ']:' + img[i].src); } }}; 补充 偏移量(1234567891011121314&gt; * ```offsetWidht``` : 元素在水平方向上占用的空间大小。包括元素的宽度、水平滚动条的宽度、左右边框的宽度。&gt; * ```offsetHeight``` : 元素在垂直方向上占用的空间大小。包括元素的高度、垂直滚动条的高度、上下边框的高度。&gt; * ```offsetLeft``` : 元素的左边框至包含元素的左内边距的距离。（offsetParent） &gt; * ```offsetTop``` : 元素的上边框至包含元素的上内边距的距离。（offsetParent）```offsetParent```为相对于元素定位的父级元素```offsetTop``` 和 ```offsetLeft``` 与其包含元素```offsetParent```有关。```offsetParent```的值不一定与```parentNode```相同。这些偏移量属性均为**只读**。![偏移量 offset](http://cloud.xuww.wang/offset.jpg)#### 客户区大小（```client dismension```）&gt; * clientWidth : 元素内容区宽度加上左右内边距。```content + padding-left + padding-right clientHeight : 元素内容区高度加上上下内边距。+ padding-top + padding-bottom```123456client dismension 值也是**只读**的。```javascriptlet clientWidth = document.documentElement.clientWidht;let clientHeight = document.documentElement.clientHeight; 滚动大小（dismension```）1234567&gt; * ```scrollTop``` : 被隐藏在内容区域上方的高度。（上方被隐藏了多少）&gt; * ```scrollLeft``` : 被隐藏在内容区域左侧的宽度。（左侧被隐藏了多少）&gt; * ```scrollWidth``` : 在没有滚动的情况下，元素内容的总宽度。&gt; * ```scrollHeight``` : 在没有滚动的情况下，元素内容的总高度。* 带有垂直滚动条的页面总高度：```document.documentElement.scrollHeight 带有水平滚动条的页面总宽度：12345678910* 通过scrollLeft和scrollTop既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。```javascript// 确定文档的总高度//scrollHeight和clientHeight中的最大值let docHeight = Math.max(documnt.documentElement.scrollHeight, document.documntElement.clientHeight);// 确定文档的总宽度//scrollWidth和clientWidth中的最大值let docWidth = Max.max(document.documentElement.scrollWidth, document.documentElement.clientWidth);","link":"/2017/09/20/css-lazy-load-image/"},{"title":"css文字两端对齐","text":"文本内容可以实现左对齐、右对齐以及居中对齐，如何实现两端对齐？很多时候为了对齐文字中间使用空格来隔开，这样每个内容需要计算空格个数，当内容不一样长短的时候又通过JS进行麻烦的计算。 text-align是控制文字的对齐与显示，从其属性名上就可以看出来。从其渲染与解析上来看，其主要是用来控制inline水平元素或inline-block元素的对齐与显示的，例如嵌套行内标签的文字、图片、input表单控件等；而对block水平的元素是没有作用的。 12text-align: center | left | right | start | end | justify | inherit | initial | unsettext-align: justify css2中text-align有一个属性为justify，居中对齐。其实现的效果就是可以让一行文字两端对齐显示（文字内容要超过一行） 有多行文字 多行文字内容时直接使用justify可以实现两端对齐效果 1&lt;div&gt;Vue.js (读音 /vjuː/，类似于 view) 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。&lt;/div&gt; 12345div { width: 500px; border: 1px solid #000; text-align: justify;} 只有一行文字 需要在文字后面加一个占位元素，可以使用伪类元素实现，或者加&lt;span&gt;&lt;/span&gt;、&lt;i&gt;&lt;/i&gt;空元素。 1&lt;div&gt;css文字两端对齐！&lt;/div&gt; 12345div { width: 500px; border: 1px solid #000; text-align: justify;} 此时的效果并没有实现两端对齐，因为文字内容没有换行。可以使用伪类元素实现。12345678910div { width: 500px; border: 1px solid #000; text-align: justify;}div:after { content: ''; display: inline-block; width: 100%;}","link":"/2017/10/16/css-text-align-justify/"},{"title":"canvas精灵","text":"requestAnimationFrame使用 canvas 实现精灵动画CREATE A SPRITE ANIMATION WITH HTML5 CANVAS AND JAVASCRIPTwindow.requestAnimationFrameCSS3动画那么强，requestAnimationFrame还有毛线用？HTML5 canvas drawImage() 方法","link":"/2018/04/18/canvas精灵/"},{"title":"SVG基础入门","text":"可缩放矢量图形，即SVG，是W3C XML的分枝语言之一，用于标记可缩放的矢量图形。（摘自MDN） version： 表示&lt;svg&gt;的版本 xmlns：http://www.w3.org/2000/svg 固定值 xmlns:xlink：http://www.w3.org/1999/xlink 固定值 xml:space：preserve 固定值，上述三个值固定，表示命名空间，当数据单独存在svg文件内时，这3个值不能省略 class: class类名 width | height： 定义 svg 画布的大小 viewbox： 定义了画布上可以显示的区域，当 viewBox 的大小和 svg 不同时，viewBox 在屏幕上的显示会缩放至 svg 同等大小。 有了 svg 标签，我们就可以愉快的在内部添加 SVG 图形了。 12345678&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\"/&gt;&lt;/svg&gt; 第一行包含了 XML 声明。standalone 属性规定此 SVG 文件是否是“独立的”，或含有对外部文件的引用。standalone=”no” 意味着 SVG 文档会引用一个外部文件。 SVG 代码以 &lt;svg&gt;元素开始，包括开启标签 &lt;svg&gt; 和关闭标签&lt;/svg&gt; 。width 和 height 属性可设置此 SVG 文档的宽度和高度。version属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。","link":"/2017/09/27/css-svg-basic/"},{"title":"css控制文本内容溢出截断","text":"css控制文字内容的溢出显示，溢出截断后末尾出现省略 ... ，单行文本与多行文本的控制又有区别。 单行文本 12345.text { overfolw: hidden; text-overflow: ellipsis; white-space: nowrap;} 多行文本 123456.text { display:-webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; overflow: hidden;} 知识点 text-overflow 确定内容的溢出显示，可以被剪切(clip)、显示一个省略号（...）或者显示一个自定义字符串。 需要设置 overflow: hidden 属性才能生效，否则不会强制溢出事件发生。 属性只对块级元素溢出的内容有效，但必须与块级元素内联（ inline ）方向一致。如内容在盒子下方溢出，则属性不会生效。 文本溢出：1、文本无法换行，设置了 white-space: nowrap; 。2、单词太长。 1text-overflow: [ clip | ellipise | &lt;string&gt; ]{1, 2} clip: 内容区域的极限处截断文本，因此可能在字符的中间可能会发生截断。为了能够在两个字符过度处截断，必须使用一个空字符串值（）。 ellipse: 用省略号...来表示截断的文本。如果空间太小连省略号也不能显示，那么省略号也会被截断。 &lt;string&gt;: &lt;string&gt;用来表示被截断的文本。字符串内容将被添加在内容区域中，所以会减少显示出的文本。如果空间太小到连省略号的容纳下，那么这个字符串也会被截断。 123456789101112131415161718192021/* Overflow behavior at line endRight end if ltr, left end if rtl */text-overflow: clip;text-overflow: ellipsis;text-overflow: \"…\";text-overflow: fade;text-overflow: fade(10px);text-overflow: fade(5%);/* Overflow behavior at left end | at right endDirectionality has no influence */text-overflow: clip ellipsis;text-overflow: \"…\" \"…\";text-overflow: fade clip;text-overflow: fade(10px) fade(10px);text-overflow: fade(5%) fade(5%);/* Global values */text-overflow: inherit;text-overflow: initial;text-overflow: unset; div br{ display: none; } CSS value direction: ltr direction: rtl Expected Result Live result Expected Result Live result visible overflow 1234567890 1234567890 0987654321 1234567890 text-overflow: clip 123456 1234567890 text-overflow: ‘’ 12345 123456 54321 1234567890 text-overflow: ellipsis 1234… 1234567890 …4321 1234567890 text-overflow: ‘.’ 1234. 1234567890 .4321 1234567890 text-overflow: clip clip 123456 1234567890 654321 1234567890 text-overflow: clip ellipsis 1234… 1234567890 6543… 1234567890 text-overflow: clip ‘.’ 1234. 1234567890 6543. 1234567890 text-overflow: ellipsis clip …3456 1234567890 …4321 1234567890 text-overflow: ellipsis ellipsis …34… 1234567890 …43… 1234567890 text-overflow: ellipsis ‘.’ …34. 1234567890 …43. 1234567890 text-overflow: ‘,’ clip ,3456 1234567890 ,4321 1234567890 text-overflow: ‘,’ ellipsis ,34… 1234567890 ,43… 1234567890 text-overflow: ‘,’ ‘.’ ,34. 1234567890 ,53. 1234567890","link":"/2017/10/19/css-text-overflow/"},{"title":"externals外部扩展理解","text":"如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals。 externals 配置选项提供从输出的bundle中排除依赖 可以解决npm run build打包后vender.js文件过大的问题 防止将某些import的包（package）打包到bundle（vue-cli2默认输出文件名为vender.js）中，而是运行时再从外部获取这些扩展依赖（external dependencies）,如第三方类库。 类型 string array object function regex 配置 配置externals，这样就剥离了那些不需要改动的依赖，不再把这些类库一起打包 123456789101112131415// webpack.config.jsmodules.exports = { ... externals: { &apos;jquery&apos;: &apos;jQuery&apos;, &apos;vue&apos;: &apos;Vue&apos;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;vuex&apos;: &apos;Vuex&apos;, lodash : { commonjs: &apos;lodash&apos;, amd: &apos;lodash&apos;, root: &apos;_&apos; // 指向全局变量 } }} 第二种方式描述了外部library所有可用的访问方式。这里loadsh这个外部的library可以在AMD和CommonJS模块系统中通过loadsh访问。但在全局变量形式下用_访问。 剥离第三方依赖，需要在index.html中引入123&lt;script src=\"http://storage.jd.com/campus-inviting/vue.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://storage.jd.com/campus-inviting/vue-router.min.js\"&gt;&lt;/script&gt;&lt;script src=\"http://storage.jd.com/campus-inviting/vuex.min.js\"&gt;&lt;/script&gt; webpack externals 深入理解","link":"/2019/04/09/externals外部扩展理解/"},{"title":"flex布局在UC和微信浏览器下的兼容性问题","text":"flex布局UC和微信浏览器下的兼容性问题所有webkit内核的浏览器（包括移动端）都支持 flex 布局，只不过一些浏览器只支持旧语法，如：display: -webkit-box 。旧语法和标准的 flex 语法有较大区别，需要做好兼容。不过可以来使用 autoprefixer 来自动处理这些兼容性问题，而开发时只需要写标准的语法就好了。 假如没有使用autoprefixer，在UC浏览器和微信内置浏览器中，使用display:flex;时会不起作用，要加上兼容性写法。12345display: -webkit-box; /* OLD - iOS 6-, Safari 3.1-6 */display: -moz-box; /* OLD - Firefox 19- (buggy but mostly works) */display: -ms-flexbox; /* TWEENER - IE 10 */display: -webkit-flex; /* NEW - Chrome */display: flex; 使用flex:1;时也要添加兼容性写法 width: 20%; width: 20%; /* For old syntax, otherwise collapses. */ -webkit-box-flex: 1; /* OLD - iOS 6-, Safari 3.1-6 */ -moz-box-flex: 1; /* OLD - Firefox 19- */ -webkit-flex: 1; /* Chrome */ -ms-flex: 1; /* IE 10 */ flex: 1; flex.css","link":"/2018/04/03/flex布局在UC和微信浏览器下的兼容性问题/"},{"title":"清空git缓存","text":"清空git缓存 123git rm -r --cached .git add .git commit -m 'update .gitignore'","link":"/2017/09/25/git-rm-cache/"},{"title":"git基础","text":"github上创建新的项目后，在本地拉取项目或者将本地的项目关联到建立的仓库。 1# git clone git@github.com:xxxxxxxxx.git 命令行新建一个新的仓库12345678# mkdir myProject# cd myProject # echo '# my new project' &gt;&gt; README.md# git init# git add .# git commit -m \"first commit\"# git remote add origin git@github.com:xxxxxxxxx.git# git push origin master 本地项目关联远程git仓库123# cd myProject# git remote add origin git@github.com:xxxxx/xxxx/git# git push origin master 本地分支关联远程分支12# git checkout test# git remote add origin git@github.com:xxxx/test.git fatal首次拉取代码失败 git pull错误信息 :12* branch master -&gt; FETCH_HEADfatal: refusing to merge unrelated histories 解决：1# git pull origin master --allow-unrelated-histories 首次安装git设置12# git config -global user.nme \"xxxxxx\"# git config -global user.email \"xxxxxx@jd.com\" 公钥密钥配置1# ssh-keygen -t rsa 会生成两个文件：id_rsa（密钥）和id_rsa.pub（公钥）在github中设置公钥。","link":"/2017/10/13/github-project-init/"},{"title":"JS控制GIF动画","text":"JS控制Gif动画 思想： 使用canvas获取Gif第一帧图片，静止的时候使用图片，播放的时候使用Gif。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162if ('getContext' in document.createElement('canvas')) { HTMLImageElement.prototype.play = function() { if (this.storeCanvas) { // 移除存储的canvas this.storeCanvas.parentElement.removeChild(this.storeCanvas); this.storeCanvas = null; // 透明度还原c this.style.opacity = ''; } if (this.storeUrl) { this.src = this.storeUrl; } }; HTMLImageElement.prototype.stop = function() { // polyfill 提供了这个方法用来获取设备的 pixel ratio let getPixelRatio = function(context) { let backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1; return (window.devicePixelRatio || 1) / backingStore; }; let canvas = document.createElement('canvas'); let ratio = getPixelRatio(canvas); // 尺寸 let width = +this.width; let height = +this.height; if (width &amp;&amp; height) { // 存储之前的地址 if (!this.storeUrl) { this.storeUrl = this.src; } // canvas大小 canvas.width = width * ratio; canvas.height = height * ratio; // 绘制图片帧（第一帧） // 注意，这里的 width 和 height 变成了 width * ratio 和 height * ratio canvas.getContext('2d').drawImage(this, 0, 0, width * ratio, height * ratio); canvas.style.width = width; canvas.style.height = height; // 重置当前图片 try { this.src = canvas.toDataURL('image/gif'); } catch (e) { console.log(e); // 跨域 this.removeAttribute('src'); // 载入canvas元素 canvas.style.position = 'absolute'; // 前面插入图片 this.parentElement.insertBefore(canvas, this); // 隐藏原图 this.style.opacity = '0'; // 存储canvas this.storeCanvas = canvas; } } };}","link":"/2018/02/02/js-contro-gif-md/"},{"title":"AJAX异步请求","text":"AJAX： Asyncchronous Javascript + XMLLAjax的技术核心是XMLHttpRequest对象，简称XHR。 XMLHttpRequest对象（XHR） 以异步的方式从服务器获取数据，获取新数据后，通过DOM的方式将新数据插入到页面中。 1. 新建XHR对象 IE7+、现代浏览器都支持原生的XHR对象 1var xhr = new XMLHttpRequest(); 2. open(method, url, boolean) open() 方法并不会真正发送请求，而是启动一个请求以备发送。同域、同端口、同协议 method: 发送请求的类型（get、post、delete、put等） url： 请求URL（相对路径是相对于当前页面或者绝对路径） boolean： 是否异步发送请求 3. send() 一个参数，作为请求主体发送的数据，或者为null（body中的数据）默认情况下，服务器对POST请求和表单提交的请求不会一视同仁。因此服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分。可以使用XHR来模仿表单提交： 1、将content-Type头部信息设置成application/x-www-form-urlencoded 2、serialize()函数序列化表单内容。 收到相应请求后，响应数据会自动填充XHR对象的属性。 responseText 作为响应主体被返回的文本。 responseXML 如果响应类型是text/xml或者application/xml，这个属性中保存着包含响应数据的XML DOM文档。 status HTTP响应状态 statusText HTTP响应状态说明 异步请求，检测XHR对象的readyState属性，该属性表示请求/响应过程中的当前活动阶段。 0 ： 未初始化。尚未调用open()方法。 1 ： 启动。已经调用open()方法， 但未调用send()方法。 2 ： 发送。已经调用send()方法， 但未接收到响应。 3 ： 接收。已经接收到部分响应数据。 4 ： 完成。已经接收到全部响应数据，已经可以在客户端使用。 readyState值变化都会触发readystatechange事件。 同步方式请求12345678910var xhr = new XMLHttpRequest();xhr.open('get', 'example.json', false);xhr.send(null);if((xhr.status &gt; 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ //xhr.responseText; //通过检测xhr.status来检测请求返回状态，不要依赖statusText，因为跨浏览器时statusText不可靠}else{ //请求错误, 输出错误log：xhr.status} 异步方式请求1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status &gt; 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){ alert(xhr.reponseText); }else{ alert(\"Request was unsuccessful: \" + xhr.status); }}xhr.open('get', 'example.json', true);xhr.send(null); 4. 取消异步请求xhr.abort() 5.HTTP头部信息 Accept 浏览器处理的内容类型 Accept-Charset 显示的字符集 Accept-Econding 处理的压缩编码 Connection 与服务器之间的连接类型 Cookie Cookie设置 Host 发出请求所在的域 Referer 发出请求坐在的URI xhr.setRequestHeader('HeaderName', 'HeaderVal'); 使用自定义的头部字段名称，有些浏览器禁止修改默认的头部字段 。xhr.getResponseHeader('HeaderName');xhr.getAllResponseHeaders(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function create_connect_obj(){ if(window.ActiveXObject!='undefined' &amp;&amp; window.ActiveXObject!=undefined){ // 兼容IE7以下，可以忽略 return new ActiveXObject('Microsoft.XMLHTTP'); }else if(window.XMLHttpRequest!='undefined' &amp;&amp; window.XMLHttpRequest!=undefined){ return new XMLHttpRequest(); }}var doget=function(url,data,success,fail){ var conn=create_connect_obj(); if(typeof(data)=='object'){ var str=''; for(var i in data){ str+='&amp;'+i+'='+data[i]; } str=str.substr(1); if(url.indexOf('?')!=-1){ url+=str; }else{ url+='?'+str; } }else if(typeof(data)=='string'){ if(url.indexOf('?')!=-1){ url+=data; }else{ url+='?'+data; } } conn.open('GET',url); conn.send(null); conn.onreadystatechange=function(){ if(conn.readyState==4 &amp;&amp; conn.status==200){ if(typeof(data)=='function'){ data(conn.response); }else if(typeof(success)=='function'){ success(conn.response); //success } }else{ if(typeof(fail)=='function'){ //fail fail(); } } }}var dopost=function(url,data,success,fail){ var conn=create_connect_obj(); conn.open('POST',url); conn.setRequestHeader('Content-type','application/x-www-form-urlencoded'); if(typeof(data)=='object'){ var str=''; for(var i in data){ str+='&amp;'+i+'='+data[i]; } str=str.substr(1); conn.send(data); }else if(typeof(data)=='string'){ conn.send(data); }else{ conn.send(null); } conn.onreadystatechange=function(){ if(conn.readyState==4 &amp;&amp; conn.status==200){ if(typeof(data)=='function'){ data(conn.response); }else if(typeof(success)=='function'){ success(conn.response); //success } }else{ if(typeof(fail)=='function'){ //fail fail(); } } }}","link":"/2017/09/26/javascript-ajax/"},{"title":"margin、padding的百分比计算","text":"CSS2.1 Box model The percentage is calculated with respect to the width of the generated box’s containing block. Note that this is true for margin-top and margin-bottom as well. margin：百分比的计算基于生成框的包含块(父元素)的width（margin-top/bottom也是如此）。padding同理","link":"/2018/04/20/margin、padding的百分比计算/"},{"title":"webpack-spritesmith雪碧图","text":"项目开发设计师没有提供svg或者icon-font，只能使用图片，过多的小图片造成资源浪费，解决方案：webpack打包将多个图标合成雪碧图 需要同时配置开发环境和线上环境的webpack配置 webpack-spritesmith 合成雪碧图插件 file-loader | build | | | |--utils.js | |--webpack.base.config.js | |--webpack.dev.config.js | |--webpack.pro.config.js | |src | | | |--assets | | | | | |--css | | |--incons | | | |-sprites 1. 修改webpack.base.config.js resolve modules 添加resolve和处理雪碧图资源的loader 123456789101112131415161718192021222324252627282930resolve: { modules: [ 'node_modules', 'src/sprites' // 合成sprite图片地址 ]}modules: { rules: [ ... // 对需要合成雪碧图的资源不进行base64转换 { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, exclude: path.join(__dirname, 'src/assets/icons'), loader: 'url-loader', options: { limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') } }, // 对图标单独设置，以便生成雪碧图 { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, include: path.join(__dirname, 'src/assets/icons'), loaders: [ 'file-loader?name=i/[hash].[ext]' // 使用file-loader 对 png 图标进行设置 ] }, ]} 2. 修改webpack.dev.config.js 添加plugin 123456789101112131415161718192021222324252627282930313233343536373839const utils = require('./utils')const SpritesmithPlugin = require('webpack-spritesmith')plugins: [ // 雪碧图设置 new SpritesmithPlugin({ src: { cwd: path.resolve(__dirname, '../src/assets/icons'), // 图标根路径 glob: '*.png' // 匹配任意 png 图标 }, target: { image: path.resolve(__dirname, '../src/sprites/sprites.png'), // 生成雪碧图目标路径与名称 // 设置生成CSS背景及其定位的文件或方式 css: [ [ path.resolve(__dirname, '../src/sprites/sprites.css'), { format: 'function_based_template' } ], [ path.resolve(__dirname, '../src/sprites/_sprites.scss'), { format: 'handlebars_based_template' } ], ] }, customTemplates: { 'function_based_template': utils.cssTemplateFunction, 'handlebars_based_template': utils.scssTemplateFunction }, apiOptions: { cssImageRef: \"~sprites.png\", // css文件中引用雪碧图的相对位置路径配置 }, // retina: '@2x', spritesmithOptions: { padding: 8, }, // When set to true will console.log list of created files. logCreatedFiles: true }),] 3.修改utils.js 打包中使用webpack-spritesmith插件使用自定义生成css/scss文件的模版方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344exports.cssTemplateFunction = data =&gt; { const shared = '.icon { background-image: url(I); }' .replace('I', data.sprites[0].image); // 注意：此处默认图标使用的是二倍图 const perSprite = data.sprites.map(function (sprite) { // background-size: SWpx SHpx; return '.icon-N { width: Wpx; height: Hpx; background-position: Xpx Ypx;}' // return '.icon-N { width: SWpx; height: SHpx; background-position: Xpx Ypx;}\\n.icon-N .icon, .icon-N.icon { width: Wpx; height: Hpx; background-position: Xpx Ypx; } ' .replace(/N/g, sprite.name) .replace(/SW/g, sprite.width / 2) .replace(/SH/g, sprite.height / 2) .replace(/W/g, sprite.width) .replace(/H/g, sprite.height) .replace(/X/g, sprite.offset_x) .replace(/Y/g, sprite.offset_y); }).join('\\n'); return shared + '\\n' + perSprite;};exports.scssTemplateFunction = data =&gt; { // console.log(data, '==========', data.spritesheet) const mixs = `$screen:750; @function px2rem($px) { @return #{$px/($screen/10)}rem }` const shared = '.icon { background-image: url(I); background-size: px2rem\\(W\\) px2rem\\(H\\);}' .replace('I', data.sprites[0].image) .replace(/W/g, data.spritesheet.width) .replace(/H/g, data.spritesheet.height) // 注意：此处默认图标使用的是二倍图 const perSprite = data.sprites.map(function (sprite) { return '.icon-N { width: px2rem\\(W\\); height: px2rem\\(H\\); background-position: px2rem\\(X\\) px2rem\\(Y\\);} ' .replace(/N/g, sprite.name) .replace(/SW/g, sprite.width / 2) .replace(/SH/g, sprite.height / 2) .replace(/W/g, sprite.width) .replace(/H/g, sprite.height) .replace(/X/g, sprite.offset_x) .replace(/Y/g, sprite.offset_y); }).join('\\n'); return mixs + '\\n' + shared + '\\n' + perSprite;}; 参考 雪碧图处理工具 webpack-spritesmith github","link":"/2019/04/09/webpack-spritesmith雪碧图/"},{"title":"localstroge本地缓存","text":"localStorage设置过期时间123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119define(\"localStorage\", function(require, exports, module){ var cache = require(\"cachev1\").local; var Promise = require(\"promise.min\"); /** * 将过期时间字符串转换成时间戳 * convertExpire(\"7d\") * convertExpire(3600) 1小时 * @param {String} val 过期时间，格式为`\\d+[smhd]`，其中s 表示秒、m 分钟、h 小时、d 天，如 30d 默认是秒 * @return {Number} 时间戳（单位s） */ function convertExpire(val) { if (!val) return 0; var matches = ('' + val).match(/(\\d+)([smhd])/); var ms = 0; if (matches) { switch (matches[2]) { case 's': ms = matches[1]; break; case 'm': ms = matches[1] * 60; break; case 'h': ms = matches[1] * 60 * 60; break; case 'd': ms = matches[1] * 24 * 60 * 60; } } else{ ms = val; } return ms; } var timeout = setTimeout; var storage = { /** * 将数据写入本地缓存 * * @param {String} key 键名 * @param {Object | String} value 数据 * @param {Object} options 可选项，可传expire 设定数据过期时间，格式参见convertExpire * * @return {Promise} Promise实例 */ set:function(key, value, options) { return new Promise(function(resolve, reject){ var expire = convertExpire(typeof options == 'object' &amp;&amp; options.expire ? options.expire : '7d'); timeout(function () { cache.setItem(key,value,expire,function (ret) { if(ret==0) resolve(); else reject(); }); }); }) }, /** * 获取本地缓存数据，当数据已过期时会被清理掉 * * @param {String} key 键名 * @param {Mix} defaultVal 如设置了默认值，则保证不会被reject * * @return {Promise} Promise实例 */ get:function(key, defaultVal) { return new Promise(function(resolve, reject){ timeout(function () { var value = cache.getItem(key); if(value===\"\"||value===null){ if(typeof defaultVal!=\"undefined\"){ resolve(defaultVal); }else{ reject(); } return; } resolve(value); }); }) }, /** * 移除本地缓存数据 */ remove:function(key) { return new Promise(function(resolve, reject){ timeout(function () { cache.removeItem(key); resolve(); }); }) }, /** * 同步地设置本地缓存数据 * * @deprecated 此方法只为了暂时兼容旧接口，会极大的影响性，能请勿使用！ */ setSync:function(key, value, options) { var expire = convertExpire(typeof options == 'object' &amp;&amp; options.expire ? options.expire : '7d') cache.setItem(key,value,expire); }, /** * 同步地获取本地缓存数据，当数据已过期时会被清理掉 * * @deprecated 此方法只为了暂时兼容旧接口，会极大的影响性，能请勿使用！ */ getSync:function(key) { return cache.getItem(key); } } module.exports = storage;});","link":"/2018/05/30/localstroge本地缓存/"},{"title":"sass基础入门","text":"css功能拓展嵌套（Nested Rules）sass允许将css样式嵌套进另一套样式中，内层的样式将他的外层的选择器作为父选择器。 父选择器 &amp; (Referencing Parent Selectors: &amp;)属性嵌套 (Nested Properties)1234567.funky { font: { family: fantasy; size: 30em; weight: bold; }} 占位符选择器 %foo (Placeholder Selectors: %foo) SassScript变量 $ (Variables: $)12345$width: 5em;#main { width: $width;} 变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。将局部变量转换为全局变量可以添加 !global 声明12345678#main { $width: 5em !global; width: $width;}#sidebar { width: $width;}","link":"/2018/04/03/sass基础入门/"},{"title":"vue中keep-alive","text":"keep-alive使用&lt;keep-alive&gt;包裹动态的组件，会缓存不活动的组件实例，而不是销毁他们。&lt;keep-alive&gt;是一个抽象的组件，他自身不会渲染一个DOM元素，也不会出现在父组件链中。当组件在&lt;keep-alive&gt;组件内被切换，它的actived和deactived这两个生命周期钩子函数将会被对应执行。 Vue2.2.0及以上版本，activated 和 deactivated 将会在 &lt;keep-alive&gt; 树内的所有嵌套组件中触发。主要用于保留组件状态或避免重新渲染。 当引入&lt;keep-alive&gt;的时候，页面第一次进入，钩子的触发顺序created -&gt; mounted -&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。 &lt;keep-alive&gt;之后页面模板第一次初始化解析变成HTML片段后，再次进入就不在重新解析而是读取内存中的数据，即，只有当数据变化时，才使用VirtualDOM进行diff更新。故，页面进入的数据获取应该在activated中也放一份。数据下载完毕手动操作DOM的部分也应该在activated中执行才会生效。 所以，应该activated中留一份数据获取的代码，或者不要created部分，直接将created中的代码转移到activated中。 1234567891011121314151617&lt;!-- 基本 --&gt;&lt;keep-alive&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 多个条件判断的子组件 --&gt;&lt;keep-alive&gt; &lt;comp-a v-if=\"a &gt; 1\"&gt;&lt;/comp-a&gt; &lt;comp-b v-else&gt;&lt;/comp-b&gt;&lt;/keep-alive&gt;&lt;!-- 和 `&lt;transition&gt;` 一起使用 --&gt;&lt;transition&gt; &lt;keep-alive&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/transition&gt; include 和 excludeinclude 和 exclude 属性允许组件有条件地缓存。二者都可以用逗号分隔字符串、正则表达式或一个数组来表示：1234567891011121314&lt;!-- 逗号分隔字符串 --&gt;&lt;keep-alive include=\"a,b\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include=\"/a|b/\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include=\"['a', 'b']\"&gt; &lt;component :is=\"view\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; actived 和 deactived 类型：Function 说明：&lt;keep-alive&gt;组件 激活/停用 时调用（该钩子在服务器端渲染期间不被调用） 应用项目开发中，使用Vue2.0 搭配路由切换vue-router，所有路径匹配到的视图组件都会被缓存。如何使某些组件不缓存？ 12345&lt;keep-alive&gt; &lt;router-view&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt; #1. 使用include和exclude12345&lt;keep-alive include='a,b,c' exclude='d,e,f'&gt; &lt;router-view&gt; &lt;!-- 所有路径匹配到的视图组件都会被缓存！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt; #2. 使用router.meta属性设置路由，通过meta属性判断组件是否需要缓存 123456789101112131415161718// routes 配置export default [ { path: '/', name: 'home', component: Home, meta: { keepAlive: true // 需要被缓存 } }, { path: '/:id', name: 'edit', component: Edit, meta: { keepAlive: false // 不需要被缓存 } }] 123456789&lt;keep-alive&gt; &lt;router-view v-if=\"$route.meta.keepAlive\"&gt; &lt;!-- 这里是会被缓存的视图组件，比如 Home！ --&gt; &lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=\"!$route.meta.keepAlive\"&gt; &lt;!-- 这里是不被缓存的视图组件，比如 Edit！ --&gt;&lt;/router-view&gt; 部分转载vue-router 之 keep-alive","link":"/2018/04/03/vue中keep-alive/"},{"title":"圣杯布局（双飞翼布局）","text":"圣杯布局圣杯布局与双飞翼布局针对的都是三列左右栏固定中间栏边框自适应的网页布局 三列布局，两边固定宽度，中间自适应 中间栏要在浏览器优先渲染 main元素必须是container的第一个元素 允许任意列的高度最高 123456&lt;div class=\"container\"&gt; &lt;!--中间栏需要优先渲染--&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 1、相对布局12345678910111213141516171819202122232425262728293031.container { width: 100%; box-sizing: border-box; min-height: 300px; padding: 0 60px;}.container &gt; div { position: relative; float: left;}.left, .right { width: 60px; height: 100%;}.left { left: -60px; margin-left: -100%;}.right { right: 0; margin-right: -100%;}.main { width: 100%; height: 100%;} 2、flex布局123456789101112131415.container { width: 100%; min-height: 300px; display: flex;}.main { flex-grow: 1;}.left { order: -1; flex-basis: 60px;}.right { flex-basis: 60px;} 3、绝对布局1234567891011121314151617181920212223.container { width: 100%; min-height: 300px; position: relative;}.container &gt; div { position: absolute;}.left, .right { width: 60px; height: 100%;}.main { width: calc(100% - 120px); height: 100%; left: 60px;}.left { left: 0;}.right { right: 0;}","link":"/2019/04/09/圣杯布局（双飞翼布局）/"},{"title":"头条前端面试","text":"头条前端面试题前两天收到头条的面试邀请，抱着试试看的心态面了一次，才发现自己水平有多差。面完后回忆起大部分面试问题，供大家参考一下 一面 line-height，区别，rem 1234line-height:26px;line-height:1.5;line-height:150%;line-height:1.5rem; setTimeout, requestAnimationFrame 区别，setTimeout没有设置时间的区别 12345678910111213setTimeout(function () { setTimeout(function () { console.log(1) }, 100); console.log(2); setTimeout(function () { console.log(3) }, 0)}, 0)setTimeout(function () { console.log(4)}, 100);console.log(5) 实现String duplicate transform: translateZ(0); 输出 12345678910111213141516171819202122232425262728// 1window.name = 'ByteDance';class A { constructor() { this.name = 123; } getA() { console.log(this); return this.name + 1; }}let a = new A();let funcA = a.getA;funcA();// 2var length = 10;function fn() { alert(this.length);}var obj = { length: 5, method: function (fn) { fn(); //? arguments[0](); //? }};obj.method(fn); 柯理化实现 前端渲染模版实现 http头部，浏览器怎么判断请求结束content-length TCP协议介绍 BFC实现、作用 position的新增属性12310:28:04 系统: 面试官已经进入173666号房间10:28:16 系统: 当前通话配置：高清模式 + 标准通道11:17:25 系统: 面试官已经离开173666号房间 二面HTML window.onload和document.ready的区别 iframe，如何在页面中改变另一个iframe的样式 尽可能多的方法隐藏一个html元素 CSS 盒模型,IE盒模型和标准盒模型，如何改变 选择器优先级（内联样式在何处） LESS和SCSS的好处 JS 请为所有数组对象添加一个findDuplicate(n)方法，用于返回该数组中出现频率&gt;=n的元素列表 123[1,2,3,4,1,2,2,2].findDuplicate(2) =&gt; [1,2][1,2,3,4,1,2,2,2].findDuplicate(5) =&gt; [][1,2,3,4,1,2,2,2].findDuplicate(-1) =&gt; [1,2,3,4] 箭头函数的好处 判断数组 原型链中prototype和–proto–分别指什么 require和import的区别 class实现原理 async和await实现原理 node中事件队列模型 fetch api HTTP和HTTPS的区别，如何升级成HTTPS 如何让网页离线后还能访问 强缓存和协商缓存 其他 vue中用到的设计模式 常见的loader和plugin，loader和plugin的区别 你的简历中有什么亮点，介绍一下","link":"/2019/04/09/头条前端面试/"},{"title":"webpack插件关于autoprefixer的冲突","text":"1. 实际遇到的问题项目中经常会遇到css的一些奇怪问题，有些css属性的设置在在本地编译运行的时候是好的，但是打包上线之后这个属性就平白无故的没有了？ 具体场景在处理多行文本溢出时，需要使用-webkit-box-orient: vertial，在本地开发测试一切正常，但是在webpack编译之后，检查样式并没有这个属性，其他的属性都有。 12345678910// 多行文本@mixin textmultiline($line:2) { display: -webkit-box; /* autoprefixer: off*/ -webkit-box-orient: vertical; /* autoprefixer: on*/ -webkit-line-clamp: $line; overflow: hidden; text-overflow: ellipsis;} 2. 为什么啊？ why remove -webkit-box-orient property? #357 Autoprefixer setting should be false by default #252 原因： autoprefixer自动的删除了一些它觉得没有必要的属性，所以解决办法就是设autoprefixer为false，或者针对某个属性忽autoprefixer 3. 怎么办 属性忽略autoprefixer 1234// eslint-disable-next-line/* autoprefixer: off*/-webkit-box-orient: vertical;/* autoprefixer: on*/ 关闭cssnano的autoprefixer just remove the postcss config in vue-loader’s config Add the following option to prevent autoprefixer from removing prefixes (for cssnano v3 only): 12345{ autoprefixer: { remove: false }} Then -webkit-box-orient will be preserved. optimize-css-assets-webpack-plugin 插件问题 12345new OptimizeCSSPlugin({ cssProcessorOptions: config.build.productionSourceMap ? { safe: true, map: { inline: false } } : { safe: true }}),","link":"/2018/08/27/webpack-插件关于autoprefixer的冲突/"},{"title":"一些常用收集","text":"JS库 js-cookie cookie处理 nprogress 进度条 three AlloyTouch：丝般顺滑的触摸运动方案 date-fns 日期处理 html2canvas Airbnb JavaScript 编码规范：Airbnb github， 中 lazyload clipboard fullPage 全屏滚动网站 bilibili flv Echarts WebUploader 文件上传 lodash swiper Mock.js Bring data to life with SVG, Canvas and HTML. 📊📈 CSS normalize.css css_tricks：一些常用的CSS样式 Hover Animate.css 框架 taro: taro, github 🚀 飞冰 - 让前端开发简单而友好 Nerv是一款基于虚拟DOM技术的JavaScript（TypeScript）库 VUE vue 源码分析 vue-awesome-swiper 逐行级别的源码分析 Vue.js 源码解析 mint-ui 面试 前端面试手册 木易杨，「高级前端进阶」，每天一道前端大厂面试题 计算机网络 前端开发面试 📚 技术面试必备基础知识 CSS 30-seconds-of-interviews: 30s-css, github 30-seconds-of-css: 30s-css, github CSS奇技淫巧 JS 33-js-concepts 英 33-js-concepts 中 阮一峰 ES6 入门 Nodejs学习笔记以及经验总结 工具 高质量的Git中文教程 webpack-study 基于Node实现的跨平台抓包调试代理工具 轻量级web富文本框 深入浅出 Webpack 一站式页面调试、抓包工具 博客 前端工匠 Dream 冴羽博客（JavaScript深入系列、JavaScript专题系列、ES6系列、React系列） 木易杨，「高级前端进阶」 Vue相关开源项目库 手机淘宝前端团队 study-notes 开发 微信小程序商城服务端 API 微信小程序商城 Vue2 全家桶仿 微信App 项目，支持多人在线聊天和机器人聊天 🎧vuejs仿网易云音乐 🔈 Websocket project based on vue（基于vue2.0的实时聊天项目） 后台前端解决方案 d2 企业中后台产品前端集成方案 微信小程序商城 MinUI微信小程序组件库 wepy 👏vue后台管理框架👏","link":"/2019/04/17/一些常用收集/"},{"title":"微信小程序使用阿里字体图标","text":"前言为了美化微信小程序，可以使用适当的图标来美化页面，体验更好。阿里字体图标库提供了丰富的字体，各种场景下项目中所需要字体几乎都能找到。 微信小程序中设置元素的背景图片不能使用本地图片，本地资源无法通过WXSS获取，background-img可以使用网络图片或者base64，或者使用image标签，所以不能直接下载阿里字体图标库的图片设置为背景图片，可以将下载的图片转成字体文件使用。 使用1. 下载字体 2. 解压转成base64文件下载字体文件，解压缩后将.ttf文件转化，transfonter 3. 拷贝字体文件至小程序将下载好的文件夹中stylesheet.css样式表中的内容拷贝, 粘贴至小程序的wxss文件中,即可引用该iconfont字体图标. 4. 引用字体文件小程序只能识别wxss为后缀的css文件，不能识别.css文件。@import &quot;/assets/iconfont/iconfont.wxss","link":"/2018/03/21/微信小程序使用阿里字体图标/"},{"title":"时间处理","text":"时间处理方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102define(\"date\",function(require,exports,module){ var _cacheThisModule_; exports.format = function(date,formatStr){ //格式化时间 var arrWeek=['日','一','二','三','四','五','六'], str=formatStr .replace(/yyyy|YYYY/,date.getFullYear()) .replace(/yy|YY/,$addZero(date.getFullYear() % 100,2) ) .replace(/mm|MM/,$addZero(date.getMonth()+1,2)) .replace(/m|M/g,date.getMonth()+1) .replace(/dd|DD/,$addZero(date.getDate(),2) ) .replace(/d|D/g,date.getDate()) .replace(/hh|HH/,$addZero(date.getHours(),2)) .replace(/h|H/g,date.getHours()) .replace(/ii|II/,$addZero(date.getMinutes(),2)) .replace(/i|I/g,date.getMinutes()) .replace(/ss|SS/,$addZero(date.getSeconds(),2)) .replace(/s|S/g,date.getSeconds()) .replace(/w/g,date.getDay()) .replace(/W/g,arrWeek[date.getDay()]); return str; } exports.getTimeDistance = function (ts){ //根据时间差计算剩余的时间，返回[天，小时，分，秒] var timeLeft=[0,0,0,0];//结构：天、小时、分、秒 timeLeft[0]=(ts&gt;86400)?parseInt(ts/86400):0; ts=ts - timeLeft[0] * 86400; timeLeft[1]=(ts&gt;3600)?parseInt(ts/3600):0; ts=ts - timeLeft[1] * 3600; timeLeft[2]=(ts&gt;60)?parseInt(ts/60):0; timeLeft[3]=ts - timeLeft[2] * 60; return timeLeft; } exports.getTimeInterval = function (st,et){ //返回两个时间之间的间隔的描述字符串 var dateLeft = 0; var hourLeft = 0; var minuteLeft = 0; var secondLeft = 0; var timeLeft=[0,0,0,0];//结构：天、小时、分、秒 var timeStr=\"\"; var ts=(et&gt;st)?parseInt((et-st)/1000):0; timeLeft[0]=(ts&gt;86400)?parseInt(ts/86400):0; ts=ts - timeLeft[0] * 86400; timeLeft[1]=(ts&gt;3600)?parseInt(ts/3600):0; ts=ts - timeLeft[1] * 3600; timeLeft[2]=(ts&gt;60)?parseInt(ts/60):0; timeLeft[3]=ts - timeLeft[2] * 60; timeStr=(timeLeft[0]&gt;0)?timeLeft[0]+\"天\":\"\"; timeStr+=(timeLeft[0]&lt;=0 &amp;&amp; timeLeft[1]&lt;=0)?\"\":(timeLeft[1]+\"小时\"); timeStr+=(timeLeft[0]&lt;=0 &amp;&amp; timeLeft[1]&lt;=0 &amp;&amp; timeLeft[2]&lt;=0)?\"\":(timeLeft[2]+\"分钟\"); timeStr+=(timeLeft[0]&lt;=0 &amp;&amp; timeLeft[1]&lt;=0 &amp;&amp; timeLeft[2]&lt;=0 &amp;&amp; timeLeft[3]&lt;=0)?\"\":timeLeft[3]+\"秒\"; return timeStr; } function $addZero(v,size){ for(var i=0,len=size-(v+\"\").length;i&lt;len;i++){ v=\"0\"+v; }; return v+\"\"; } exports.getServerTime = function(url) { var sysTime = document.getElementById('SYSTIME'); if(sysTime){ var ts = sysTime.value.substring(0, 19).split('-'), dObj = new Date(ts[0], parseInt(ts[1], 10) - 1, ts[2], ts[3], ts[4], ts[5]); return dObj; } var xhr = $xhrMaker(), url = url || \"http://\" + window.location.hostname+\"/favicon.ico\"; try{ xhr.open(\"HEAD\", url, false); xhr.send(); }catch(e){ return new Date(); } return new Date(xhr.getResponseHeader(\"Date\")); } function $xhrMaker(){ var xhr; try{// Firefox, Opera 8.0+, Safari xhr=new XMLHttpRequest(); }catch(e){//Internet Explorer try{ xhr=new ActiveXObject(\"Msxml2.XMLHTTP\"); }catch(e){ try { xhr=new ActiveXObject(\"Microsoft.XMLHTTP\"); }catch (e){ xhr=null; } } }; return xhr; }});","link":"/2018/05/30/时间处理/"},{"title":"数组对象判断","text":"数组对象判断方法 支付宝base.js123456789if ( value instanceof Array || (!(value instanceof Object) &amp;&amp; (Object.prototype.toString.call((value)) == '[object Array]') || typeof value.length == 'number' &amp;&amp; typeof value.splice != 'undefined' &amp;&amp; typeof value.propertyIsEnumerable != 'undefined' &amp;&amp; !value.propertyIsEnumerable('splice'))) { return 'array'; } instanceof123var arr = []; arr instanceof Array; // true arr.constructor == Array; //true call/apply12345Object.prototype.toString.call(value) == '[object Array]'var isArray = function(obj) { return Object.prototype.toString.call(obj) === '[object Array]'; } typeof typeof方法返回一个字符串，来表示数据的类型。 数据类型 type 数据类型 Type Undefined undefined Null object 布尔值 boolean 数值 number 字符串 string Symbol (ECMAScript 6 新增) symbol 宿主对象(JS环境提供的，比如浏览器) Implementation-dependent 函数对象 function 任何其他对象 object 1234567891011var a = [];var b = {};typeof a; // \"object\"typeof b; // \"object\"a instanceof Object // trueb instanceof Object // truea instanceof Array // trueb instanceof Array // false","link":"/2018/04/12/数组对象判断/"},{"title":"css中position属性深入探讨","text":"对于 position 属性可以说是平时开发中使用频率非常高的 CSS 属性，本文主要对 position 做个总结。 position 属性能够很好的体现 HTML 的普通流的特征。设置 position 属性之后主要关注是否脱离文档流和改变 display 属性 position: static | relative | absolute | sticky static所有元素在默认情况下 position 属性值都为 static ，此时设置top、left、bottom和 right 在 position 为 static 的情况下无效。用法：在改变了元素的 position 属性后可以将其元素重置为 static ，让其回归到正常的普通文档流中。 relative相对定位: 指给元素设置相对于原本位置的定位，元素并不脱离文档流，因此元素原本的位置会被保留，其他的元素位置不会受到影响。 每个元素在页面中的普通流中都会占用一个位置（元素默认文档流位置），设置为相对定位后，将元素偏离元素的默认位置，但是普通文档流中依然保持着原有的默认位置，并没有脱离普通文档流。 块级元素1234567891011121314151617181920212223242526&lt;style type=\"text/css\"&gt; div{ width: 100px; height: 50px; line-height: 50px; text-align: center; color: #fff; } div .A { background: blue; } div .B { background: red; position: relative; top: 20px; left: 20px; } div .C { background: green; }&lt;/style&gt;&lt;div class=\"A\"&gt;A&lt;/div&gt;&lt;div class=\"B\"&gt;B&lt;/div&gt;&lt;div class=\"C\"&gt;C&lt;/div&gt; 在右图中的黑色虚线部分为B块的默认文档流位置，当B块设置为相对定位 relative 之后，则相对于默认位置进行偏移。C块依然保留在原位，并没有因为B块发生了偏移而随之变化。 行内元素12345678910111213141516171819&lt;style type=\"text/css\"&gt; strong { background: #808080; } em { background: #ffd800; } span { background: #b6ff00; position: relative; top: 10px; left: 10px; width: 100px; }&lt;/style&gt;&lt;strong&gt;strong&lt;/strong&gt;&lt;em&gt;em&lt;/em&gt;&lt;span&gt;span&lt;/span&gt; 行内元素在设置 relative 之后，依然是内联元素， widht 属性未生效，并没有改变行内元素的display属性（这是与 absolute 的一个重要的区别）。 absolute绝对定位: 是指给元素设置绝对的定位，相对定位的对象可以分为两种情况： 设置了 absolute 的元素如果存在有祖先元素设置了 position 属性为 relative 或者 absolute ，则这时元素的定位对象为此已设置 position 属性的祖先元素。 如果并没有设置了 position 属性的祖先元素，则此时相对于 body 进行定位。 position: absolute相对于第一个不是 static 的父级元素进行定位。如果在其节点中所有的父级祖先元素都没有设置 position 属性为 relative 或 absolute 则该元素最终将对 body 进行位置偏移。 设置绝对定位的元素会脱离普通的文档流并且改变diaplay属性。 结论： 块级元素在设置为absolute绝对定位之后，会将width设置为auto（收到父元素的影响） 行内元素在设置为absolute绝对定位之后，如果没有设置其top、left、bottom和right属性的话，浏览器会设置成auto，auto的值则是该元素的默认位置。 relative|absolute 点 应用了position: relative | absolute的元素，margin属性依然生效，尽量不要设置margin，减少干扰、不精确。 position: absolute 将会忽略根元素的padding。 行内元素使用了position: absolute之后会改变display属性，inline-block。 设置position: relative | absolute之后，会覆盖其他非定位的元素，如果不想覆盖其他元素，也可以将其z-index: -1。 fixed绝对定位。 改变行内元素的display属性，使其display属性变更为block。 会让元素脱硫文档流，不占据空间 覆盖在非定位元素 fixed 和 absolute 的区别： absolute 根据第一个不是 static 的父元素进行定位， fixed 是根据浏览器窗口定位。 sticky粘性定位: sticky 的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是 top 、 left 等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成 fixed ，根据设置的 left 、 top 等属性成固定位置的效果。 可以知道sticky属性有以下几个特点： 该元素并不脱离文档流，仍然保留元素原本在文档流中的位置。 当元素在容器中被滚动超过指定的偏移值时，元素在容器内固定在指定位置。亦即如果你设置了top: 50px，那么在sticky元素到达距离相对定位的元素顶部50px的位置时固定，不再向上移动。 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么是相对于viewport来计算元素的偏移量 position和float 当元素同时设置 position: relative 和 float: left ，则元素先浮动到相应的位置，然后在根据 top/ left / bottom / right 来发生偏移。 当元素同时设置 position: absolute 和 float: left ，则 float 失效。","link":"/2019/04/11/css中position属性深入探讨/"},{"title":"浏览器判断","text":"移动端判断浏览器环境： 微信浏览器 小程序 JD APP 浏览器 123456const uaTypes = { APP: 'app', WECHAT: 'webchat', QQ: 'qq', MOBILE: 'mobile'} 1234567891011121314151617const ua = navigator.userAgentconst type = (() =&gt; { if (/jdapp/i.test(ua)) { return uaTypes.APP } else if (/MicroMessenger/i.test(ua)) { return uaTypes.WECHAT } else if (/QQ/.test(ua)) { // 区分手机QQ和QQ浏览器 if (/MQQBrowser/i.test(ua)) { return uaTypes.MOBILE } else { return uaTypes.QQ } } else { return uaTypes.MOBILE }})()","link":"/2018/05/18/浏览器判断/"},{"title":"移动端适配方案","text":"视窗（viewport）简单理解viewport就是浏览器窗口大小。在桌面浏览器中，viewport就是浏览器窗口的高度和宽度。在移动设备中，由于移动端的viewport太窄，为了更好为CSS布局服务，所以提供了两个viewport。 虚拟viewport ： visual viewport布局viewport ： layout viewport 物理像素 physical pixel物理像素也被称为设备像素，他是显示设备中一个最小的物理设备，物理像素单位。每个像素可以根据操作系统设置自己的颜色和亮度。 设备独立像素 device-independent pixel - 逻辑像素设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以程序使用的虚拟像素，比如CSS像素，然后由相关系统转换为物理像素。 CSS像素（与设备无关像素 device-independent piexl）一个抽象单位，主要使用在浏览器上，用来精确度量Web页面上点内容。一般CSS像素称为与设备无关的像素（device-independent piexl），DIPs。 屏幕密度屏幕密度是指一个设备表面上存在的像素数量，通常以每英寸有多少像素来计算（PPI） 设备像素比（device pixel ratio）设备像素比简称为dpr，定义了物理像素和设备独立像素之间的对应关系 设备像素 = 物理像素 / 设备独立像素 在JavaScript中，可以通过window.devicePiexlRatio获取当前设备的dpr。 在css中，可以通过-webkit-device-piexl-ratio、-webkit-min-device-piexl-ratio、-webkit-max-device-piexl-ratio进行媒体查询。 常见终端设备参数终端设备的参数 UI设计与前端开发适配的协作选择一种尺寸作为设计和开发的基准，定义其余尺寸的适配规则，对于特殊适配给出设计效果 淘宝手淘团队适配协作模式 视觉稿 在开发之前，UI设计师提供含有标注的PSD文件，为视觉稿。对于移动端而言，为了做到页面高清的效果，视觉稿会遵循以下两点： 选取一款手机的屏幕宽度最为基准，iphone6（375pt * 667pt） 对于retina屏幕（如dpr = 2）,为了达到高清的效果，视觉稿的画布大小会是基准的2倍，也就是说像素点个数是原来的4倍。 iphone6：dpr：2设备独立像素：375pt * 667pt (设备宽度为375pt，设备高度667pt)物理像素：750pt * 1334pt 视觉稿按照设备独立像素设计，放大两倍UI设计师常选择iPhone6作为基准设计尺寸，交付给前端的设计尺寸是按750px * 1334px为准(高度会随着内容多少而改变)。前端开发人员通过一套适配规则自动适配到其他的尺寸。 位图像素一个位图像素是栅格图像最小的数据单元，如png、jpg、gif等。每一个位图像素都包含着一些自身的显示信息，包括显示位置、颜色值、透明度等 理论上，一个位图像素对应一个物理像素，图片才能得到完美清晰的展示。在Retina屏幕下，一个位图像素对应4个物理像素。由于单个位图像素不可以在分割，所以只能就近取色，就会出现位图像素点不够，从而导致图片模糊。 rem单位 font size of the root element. rem就是相对于根元素&lt;html&gt;的font-size来做计算。而我们的方案中使用rem单位，是能轻易的根据的font-size计算出元素的盒模型大小。 em是根据父元素的font-size计算。 flexible的实质 flexible实际上就是通过JS来动态改写meta标签 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; 源代码：1234567891011var meta = document.createElement('meta');var scale = isRetina ? 0.5 : 1;meta.setAttribute('name', 'viewport');meta.setAttribute('content', 'initial-scale=' + scale + ' ,maximun-scale=' + scale + ' ,minimum-scale=' + scale + ' ,user-scalable=no, width=device-width');if(document.doucmentElement.firstElementChild) { document.doucmentElement.firstElementChild.appendChild(meta);} else { var wrap = document.createElement('div'); wrap.appendChild(meta); document.write(wrap.innerHTML);} 动态改写&lt;meta&gt;标签 html标签上加上data-dpr属性，并且动态改写data-dpr的值。 html标签上加上font-size属性，并且动态改写font-size的值。 &lt;meta&gt;中initial-dpr会把dpr强制设置为给定的值。如果手动设置了dpr之后，不管设备是多少dpr，都会强制设置其dpr为你设置的值。不建议设置这个meta标签值(initial-dpr)，因为在flexible中，只有对iOS设备进行dpr的判断，对于Android系列，始终认为其dpr为1 px和rem转换目前Flexible会将设计稿分成100份，为了更好的兼容vw和vh，同时1rem单位被认定为10a。1234width为750px设计稿750px = 100vw = 100a1rem = 10a1rem = 75px 我们设计稿都是750px宽度，分成10份，每份为10a（10vw），也就是整个宽度为10rem，所以html对应的font-size为75px。 参考文档 A tale of two viewports - Part One A tale of two viewports - Part Two","link":"/2018/03/21/移动端适配方案/"},{"title":"跨域","text":"什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 资源跳转： A链接、重定向、表单提交 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 JSONP 利用 &lt;script&gt; 标签没有跨域限制。 优点： 兼容性好 缺点： 只能用于get 请求 12345678910111213function jsonp(url, jsonpCallback, success) { let script = document.createElement('script') script.src = url script.async = true script.type = 'text/javascript' window[jsonpCallback] = function(data) { success &amp;&amp; success(data) } document.body.appendChild(script)}jsonp('http://xxx', 'callback', function(value) { console.log(value)}) CORS CORS（跨域资源共享）：服务端设置请求头Access-Control-Allow-Origin CORS请求分为两类： 简单请求 非简单请求 简单请求请求方法： GET POST HEAD 请求头部： Accept Accept-Content Content-Language Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain 对于简单请求，浏览器直接发出CORS请求，在头信息之中，增加一个Origin字段。 Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 123Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBar 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值 withCredentials 属性CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。(除简单请求就是非简单请求) 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = &apos;http://api.alice.com/cors&apos;;var xhr = new XMLHttpRequest();xhr.open(&apos;PUT&apos;, url, true);xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 1234567891011121314151617181920212223242526272829303132333435363738OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...``` **&quot;预检&quot;请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。**除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。（1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。4.2 预检请求的回应服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。```JSHTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 4.3 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。","link":"/2019/04/09/跨域/"},{"title":"前端面试集（HTML+CSS）","text":"1. 浏览器页面有哪三层构成，分别是什么，作用是什么? 构成：结构层、表示层、行为层 分别是：HTML、CSS、JavaScript 作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。 2.HTML5的优点与缺点？优点： 网络标准统一、HTML5本身是由W3C推荐出来的。 多设备、跨平台 即时更新。 提高可用性和改进用户的友好体验； 有几个新的标签，这将有助于开发人员定义重要的内容； 可以给站点带来更多的多媒体元素(视频和音频)； 可以很好的替代Flash和Silverlight； 涉及到网站的抓取和索引的时候，对于SEO很友好； 被大量应用于移动应用程序和游戏。 缺点： 安全：像之前Firefox4的web socket和透明代理的实现存在严重的安全问题，同时web storage、web socket 这样的功能很容易被黑客利用，来盗取用户的信息和资料。 完善性：许多特性各浏览器的支持程度也不一样。 技术门槛：HTML5简化开发者工作的同时代表了有许多新的属性和API需要开发者学习，像web worker、web socket、web storage 等新特性，后台甚至浏览器原理的知识，机遇的同时也是巨大的挑战 性能：某些平台上的引擎问题导致HTML5性能低下。 浏览器兼容性：最大缺点，IE9以下浏览器几乎全军覆没。 3.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?作用 声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。 严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 意义 doctype声明指出阅读程序应该用什么规则集来解释文档中的标记。在Web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是W3C所发布的一个文档类型定义（DTD）中包含的规则。 声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的HTML 文档。 所谓的标准模式是指，浏览器按 W3C 标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。 严格模式是浏览器根据web标准去解析页面，是一种要求严格的DTD，不允许使用任何表现层的语法，如。严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行混杂模式则是一种向后兼容的解析方法，说的透明点就是可以实现IE5.5以下版本浏览器的渲染模式。 浏览器解析时到底使用标准模式还是怪异模式，与你网页中的 DTD 声明直接相关， DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略 DTD 声明 ,将使网页进入怪异模式。 4.HTML5有哪些新特性、移除了哪些元素？ Html5 新增了 27个元素，废弃了16个元素，根据现有的标准规范，把 HTML5 的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。 结构性元素主要负责web上下文结构的定义 section：在 web 页面应用中，该元素也可以用于区域的章节描述。 header：页面主体上的头部， header 元素往往在一对 body 元素中。 footer：页面的底部（页脚），通常会标出网站的相关信息。 nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。 article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。 级块性元素主要完成web页面区域的划分，确保内容的有效分割 aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。 figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。 code：表示一段代码块。 dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。 meter：表示特定范围内的数值，可用于工资、数量、百分比等。 time：表示时间值。 progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。 video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。 audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。 details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。 datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。 menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。 command：用来处理命令按钮。 5.你做的网页在哪些流览器测试过,这些浏览器的内核分别是什么? IE: trident 内核 Firefox: gecko 内核 Safari: webkit 内核 Opera: 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核 Chrome:Blink( 基于 webkit ， Google 与 Opera Software 共同开发 ) 6. 每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面） 7.说说你对HTML5认识?（是什么,为什么）是什么：HTML5指的是包括 HTML 、 CSS 和 JavaScript 在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ， RIA ），例如： AdobeFlash 、 Microsoft Silverlight 与 Oracle JavaFX 的需求，并且提供更多能有效加强网络应用的标准集。 HTML5 是 HTML 最新版本， 2014 年 10 月由万维网联盟（ W3C ）完成标准制定。目标是替换 1999 年所制定的 HTML 4.01 和 XHTML 1.0 标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。 为什么:HTML4陈旧不能满足日益发展的互联网需要，特别是移动互联网。为了增强浏览器功能 Flash 被广泛使用，但安全与稳定堪忧，不适合在移动端使用（耗电、触摸、不开放）。HTML5增强了浏览器的原生功能，符合 HTML5 规范的浏览器功能将更加强大，减少了 Web 应用对插件的依赖，让用户体验更好，让开发更加方便，另外 W3C 从推出 HTML4.0 到 5.0 之间共经历了 17 年， HTML 的变化很小，这并不符合一个好产品的演进规则。 8.对WEB标准以及W3C的理解与认识? 标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和 js 脚本、结构行为表现的分离， 文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件， 容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。 9.HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些?行内元素 a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体 ( 不推荐 ) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码 ( 在引用源码的时候需要 ) dfn - 定义字段 em - 强调 font - 字体设定 ( 不推荐 ) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线 ( 不推荐 ) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 块元素 (block element) address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是 css layout 的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h3 - 大标题 h4 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持 frame 的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表 可变元素 可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块 (map) object - object对象 script - 客户端脚本 空元素 在 HTML[1] 元素中，没有内容的 HTML 元素被称为空元素 br hr input img link meta 10.什么是WebGL,它有什么优点?WebGL（全写 Web Graphics Library ）是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加OpenGL ES 2.0 的一个 JavaScript 绑定， WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示 3D 场景和模型了，还能创建复杂的导航和数据视觉化。显然， WebGL 技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂 3D 结构的网站页面，甚至可以用来设计 3D 网页游戏等等。 WebGL完美地解决了现有的 Web 交互式三维动画的两个问题： 第一，它通过HTML脚本本身实现 Web 交互式三维动画的制作，无需任何浏览器插件支持 ; 第二，它利用底层的图形硬件加速功能进行的图形渲染，是通过统一的、标准的、跨平台的OpenGL接口实现的。通俗说WebGL中 canvas 绘图中的 3D 版本。因为原生的 WebGL 很复杂，我们经常会使用一些三方的库，如 three.js 等，这些库多数用于HTML5 游戏开发。 11.请你描述一下 cookies，sessionStorage 和 localStorage 的区别?sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的cookies会发送到服务器端。其余两个不会。Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie 。 Firefox 每个域名 cookie 限制为 50 个。 Opera 每个域名 cookie 限制为 30 个。 Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名（ name ）、值（ value ）和等号。 Opera 许 cookie 多达 4096 个字节，包括：名（ name ）、值（ value ）和等号。 Internet Explorer 允许 cookie 多达 4095 个字节，包括：名（ name ）、值（ value ）和等号。 区别： Cookie 每个域名存储量比较小（各浏览器不同，大致 4K ） 所有域名的存储量有限制（各浏览器不同，大致 4K ） 有个数限制（各浏览器不同） 会随请求发送到服务器 LocalStorage 永久存储 单个域名存储量比较大（推荐 5MB ，各浏览器不同） 总体数量无限制 SessionStorage 只在 Session 内有效 存储量更大（推荐没有限制，但是实际上各浏览器也不同） 12.说说你对HTML语义化的理解? 什么是 HTML 语义化？ 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 基本上都是围绕着几个主要的标签，像标题（ H1~H6 ）、列表（ li ）、强调（ strong em ）等等 为什么要语义化？ 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看； 用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用； 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 语义化标签 &lt;header&gt;&lt;/header&gt; &lt;footer&gt;&lt;/footer&gt; &lt;nav&gt;&lt;/nav&gt; &lt;section&gt;&lt;/section&gt; &lt;article&gt;&lt;/article&gt; SM:用来在页面中表示一套结构完整且独立的内容部分 &lt;aslde&gt;&lt;/aside&gt; SM:主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了 &lt;figure&gt;&lt;/figure&gt; SM:媒体元素，比如一些视频，图片啊等等 &lt;datalist&gt;&lt;/datalist&gt;SM:选项列表，与 input 元素配合使用，来定义 input 可能的值 &lt;details&gt;&lt;/details&gt;SM:用于描述文档或者文档某个部分的细节 ~ 默认属性为 open~ps:配合 summary 一起使用 13.link和@import的区别?1&lt;link rel='stylesheet' rev='stylesheet' href='CSS文件 ' type='text/css' media='all' /&gt; 123&lt;style type=&apos;text/css&apos; media=&apos;screen&apos;&gt; @import url(&apos;CSS文件 &apos;);&lt;/style&gt; 两者都是外部引用CSS的方式，但是存在一定的区别： link 是 XHTML 标签，除了加载 CSS 外，还可以定义RSS 等其他事务； @import属于 CSS 范畴，只能加载 CSS 。 link 引用 CSS 时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。 link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。 14.说说你对SVG理解?SVG可缩放矢量图形（ Scalable Vector Graphics ）是基于可扩展标记语言（ XML ），用于描述二维矢量图形的一种图形格式。 SVG 是W3C(‘World Wide Web ConSortium’ 即 ‘ 国际互联网标准组织 ‘) 在 2000 年 8 月制定的一种新的二维矢量图形格式，也是规范中的网络矢量图形标准。 SVG 严格遵从 XML 语法，并用文本格式的描述性语言来描述图像内容，因此是一种和图像分辨率无关的矢量图形格式。 SVG 于 2003 年 1 月14 日成为 W3C 推荐标准。 特点： 任意放缩。用户可以任意缩放图像显示，而不会破坏图像的清晰度、细节等。 文本独立。SVG图像中的文字独立于图像，文字保留可编辑和可搜寻的状态。也不会再有字体的限制，用户系统即使没有安装某一字体，也会看到和他们制作时完全相同的画面。 较小文件。总体来讲，SVG文件比那些 GIF 和 JPEG 格式的文件要小很多，因而下载也很快。 超强显示效果。SVG图像在屏幕上总是边缘清晰，它的清晰度适合任何屏幕分辨率和打印分辨率。 超级颜色控制。SVG图像提供一个 1600 万种颜色的调色板，支持 ICC 颜色描述文件标准、 RGB 、线 X 填充、渐变和蒙版。 交互 X 和智能化。 SVG 面临的主要问题一个是如何和已经占有重要市场份额的矢量图形格式 Flash 竞争的问题，另一个问题就是 SVG 的本地运行环境下的厂家支持程度。 浏览器支持Internet Explorer9，火狐，谷歌 Chrome ， Opera 和 Safari 都支持 SVG 。IE8和早期版本都需要一个插件 - 如 Adobe SVG 浏览器，这是免费提供的。 15.HTML全局属性(global attribute)有哪些?MDN: html global attribute或者W3C HTML global-attributes accesskey:设置快捷键，提供快速访问元素如aaa在windows下的firefox中按alt + shift + a可激活元素 class:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素 contenteditable: 指定元素内容是否可编辑 contextmenu: 自定义鼠标右键弹出菜单内容 data-*: 为元素增加自定义属性 dir: 设置元素文本方向 draggable: 设置元素是否可拖拽 dropzone: 设置元素拖放类型： copy, move, link hidden: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果 id: 元素id，文档内唯一 lang: 元素内容的的语言 spellcheck: 是否启动拼写和语法检查 style: 行内css样式 tabindex: 设置元素可以获得焦点，通过tab可以导航 title: 元素相关的建议信息 translate: 元素和子孙节点内容是否需要本地化 16.说说超链接target属性的取值和作用？target这个属性指定所链接的页面在浏览器窗口中的打开方式。 它的参数值主要有： _blank ：在新浏览器窗口中打开链接文件 _parent ：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数。 _self ：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。 _top ：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。 17.data-属性的作用是什么？data-xxx为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取。 需要注意的是：data-xxx之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。并不是所有的浏览器都支持.dataset 属性，测试的浏览器中只有 Chrome 和 Opera 支持。即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。 18.介绍一下你对浏览器内核的理解？浏览器内核主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS引擎。 渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加载 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS引擎：解析和执行 javascript 来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 19.常见的浏览器内核有哪些？ Trident内核： IE,MaxThon,TT,The World,360, 搜狗等。[ 又称 MSHTML] Gecko内核： Netscape6 及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核： Opera7及以上。[Opera 内核原为： Presto ，现为：Blink;] Webkit内核： Safari,Chrome 等。[ Chrome 的： Blink （ WebKit 的分支） ] 20.iframe有那些缺点？ iframe会阻塞主页面的 Onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO; iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。 21.Label的作用是什么，是怎么用的？label标签来定义表单控制间的关系 , 当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 123&lt;label for='Name'&gt;Number:&lt;/label&gt;&lt;input type=“ text “ name='Name' id='Name'/&gt;&lt;label&gt;Date:&lt;input type='text' name='B'/&gt;&lt;/label&gt; 22.如何实现浏览器内多个标签页之间的通信?WebSocket、 SharedWorker，也可以调用localstorge、 cookies 等本地存储方式；localstorge 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks： Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常； 23.如何在页面上实现一个圆形的可点击区域？ map+area(锚点图) 或者 svg border-radius 纯 js 实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 24.title与h3的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题， H1 则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时： 会重读，而 &lt;B&gt;是展示强调内容。 i内容展示为斜体， em 表示强调的文本； Physical Style Elements – 自然样式标签b, i, u, s, pre Semantic Style Elements – 语义样式标签strong, em, ins, del, code应该准确使用语义样式标签, 但不能滥用 , 如果不能确定时首选使用自然样式标签。 25.实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果？1&lt;div style='height:1px;overflow:hidden;background:red'&gt;&lt;/div&gt; 26.HTML5标签的作用?(用途) 使Web页面的内容更加有序和规范 使搜索引擎更加容易按照HTML5规则识别出有效的内容 使Web页面更接近于一种数据字段和表 27.简述一下src与href的区别？src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。 src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js脚本 ， img图片和 frame 等元素。 1&lt;script src ='js.js'&gt;&lt;/script&gt; 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加&lt;link href='common.css' rel='stylesheet'/&gt;，那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用@import 方式。 28.谈谈你对canvas的理解？canvas是HTML5中新增一个HTML5标签与操作canvas的javascript API，它可以实现在网页中完成动态的2D与3D图像技术。标记和 SVG以及 VML 之间的一个重要的不同是，有一个基于 JavaScript 的绘图 API，而 SVG 和 VML 使用一个 XML 文档来描述绘图。SVG 绘图很容易编辑与生成，但功能明显要弱一些。 canvas可以完成动画、游戏、图表、图像处理等原来需要Flash完成的一些功能。 29.WebSocket与消息推送？B/S架构的系统多使用HTTP协议 HTTP协议的特点： 1. 无状态协议 2. 用于通过 Internet 发送请求消息和响应消息 3. 使用端口接收和发送消息，默认为80端口 底层通信还是使用Socket完成。 HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送（ F5 已坏）一些变相的解决办法：双向通信与消息推送轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。优点：后端程序编写比较容易。缺点：请求中有大半是无用，浪费带宽和服务器资源。实例：适于小型应用。长轮询：客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。优点：在无消息的情况下不会频繁的请求，耗费资小。缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ，实例：WebQQ、 Hi 网页版、 Facebook IM 。长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断地往客户端输入数据。优点：消息即时到达，不发无用请求；管理起来也相对便。缺点：服务器维护一个长连接会增加开销。实例：Gmail聊天Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。优点：实现真正的即时通信，而不是伪即时。缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。实例：网络互动游戏。Websocket:WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。特点:a、事件驱动b、异步c、使用 ws 或者 wss 协议的客户端 socketd、能够实现真正意义上的推送功能缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别。 30.img的title和alt有什么区别？ alt 用于图片无法加载时显示 title 为该属性提供信息，通常当鼠标滑动到元素上的时候显示 31.表单的基本组成部分有哪些，表单的主要用途是什么？组成：表单标签、表单域、表单按钮 表单标签：这里面包含了处理表单数据所用 CGI 程序的 URL, 以及数据提交到服务器的方法。 表单域：包含了文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框、和文件上传框等。 表单按钮：包括提交按钮，复位按钮和一般按钮；用于将数据传送到服务器上的 CGI 脚本或者取消输入，还可以用表单按钮来控制其他定义了处理脚本的处理工作。主要用途：表单在网页中主要负责数据采集的功能，和向服务器传送数据。 32.表单提交中Get和Post方式的区别？ get 是从服务器上获取数据， post 是向服务器传送数据。 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。 对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为100KB 。 get 安全性非常低， post 安全性较高。 33.HTML5 有哪些新增的表单元素？HTML5 新增了很多表单元素让开发者构建更优秀的 Web 应用程序。 datalist datetime output keygen date month week time color number range email Url 34.HTML5 废弃了哪些 HTML4 标签？HTML5 废弃了一些过时的，不合理的HTML 标签： frame frameset noframe applet big center basefront 35.HTML5 标准提供了哪些新的 API？HTML5 提供的应用程序 API 主要有： Media API Text Track API Application Cache API User Interaction Data Transfer API Command API Constraint Validation API History API 36.HTML5 存储类型有什么区别？HTML5 能够本地存储数据，在之前都是使用 cookies 使用的。 HTML5 提供了下面两种本地存储方案： localStorage 用于持久化的本地存储，数据永远不会过期，关闭浏览器也不会丢失。 sessionStorage 同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 37.HTML5 应用程序缓存和浏览器缓存有什么区别？应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：1234&lt;!doctype html&gt;&lt;html manifest=”example.appcache”&gt; &lt;!-- ... --&gt;&lt;/html&gt; 与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。 38.HTML5 Canvas 元素有什么用？Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作12&lt;canvas id=” canvas1 ″ width= ” 300 ″ height= ” 100 ″ &gt;&lt;/canvas&gt; 39.除了 audio 和 video，HTML5 还有哪些媒体标签？ HTML5 对于多媒体提供了强有力的支持，除了 audio 和 video 标签外，还支持以下标签： 标签定义嵌入的内容，比如插件。&lt;embed type=” video/quicktime ” src= ” Fishing.mov ” &gt; 对于定义多个数据源很有用。1234&lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt;&lt;/video&gt; 标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。123456&lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; &lt;source src=” jamshed.ogg ” type= ” video/ogg ” &gt; &lt;track kind=” subtitles ” label= ” English ” src= ” jamshed_en.vtt ” srclang= ” en ” default&gt;&lt;/track&gt; &lt;track kind=” subtitles ” label= ” Arabic ” src= ” jamshed_ar.vtt ” srclang= ” ar ” &gt;&lt;/track&gt;&lt;/video&gt; 据源很有用。标签为诸如 video 元素之类的媒介规定外部文本轨道。 用于规定字幕文件或其他包含文本的文件，当媒介播放时，这些文件是可见的。 40.HTML5 中如何嵌入视频？ 和音频类似，HTML5 支持 MP4 、 WebM 和 Ogg 格式的视频，下面是简单示例：1234&lt;video width=” 450 ″ height= ” 340 ″ controls&gt; &lt;source src=” jamshed.mp4 ″ type= ” video/mp4 ″ &gt; Your browser does’ nt support video embedding feature.&lt;/video&gt; 4.HTML5 中如何嵌入音频？ HTML5 支持 MP3 、 Wav 和 Ogg 格式的音频，下面是在网页中嵌入音频的简单示例：1234&lt;audio controls&gt; &lt;source src=” jamshed.mp3 ″ type= ” audio/mpeg ” &gt; Your browser does’ nt support audio embedding feature.&lt;/audio&gt; 42 .新的 HTML5 文档类型和字符集是？ HTML5 文档类型很简单：123&lt;!doctype html&gt;&lt;!--HTML5 使用 UTF-8 编码示例--&gt;&lt;meta charset=” UTF-8 ″ &gt; 43.解释一下CSS的盒子模型？ 标准的css盒子模型：宽度=内容的宽度+边框的宽度+加上内边具的宽度 网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。 这些属性我们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也就是能装东西的一种箱子，也具有这些属性，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 盒子模型也有人称为框模型，HTML中的多数元素都会在浏览器中生成一个矩形的区域，每个区域包含四个组成部分，从外向内依次是：外边距（Margin）、边框（Border）、内边距（Padding）和内容（Content），其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型，加上了doctype声明，让所有浏览器都会采用标准 w3c 盒子模型去解释你的盒子。 44. 请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素 45.请你说说CSS有什么特殊性?（优先级、计算特殊值）优先级 同类型，同级别的样式后者先于前者 ID &gt; 类样式 &gt; 标签 &gt; 内联&gt;ID选择器&gt;伪类&gt;属性选择器&gt;类选择器&gt;标签选择器&gt;通用选择器()&gt;继承的样式 具体 &gt; 泛化的，特殊性即css优先级 近的 &gt; 远的 (内嵌样式 &gt; 内部样式表 &gt; 外联样式表) 内嵌样式：内嵌在元素中，span 内部样式表：在页面中的样式，写在中的样式外联样式表：单独存在一个css文件中，通过link引入或import导入的样式 !important 权重最高，比 inline style 还要高 计算特殊性值 important &gt; 内嵌 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符 权重、特殊性计算法：CSS样式选择器分为4个等级，a、b、c、d 如果样式是行内样式（通过Style=“”定义），那么a=1，1,0,0,0 b为ID选择器的总数 0,1,0,0 c为属性选择器，伪类选择器和class类选择器的数量。0,0,1,0 d为标签、伪元素选择器的数量 0,0,0,1 !important 权重最高，比 inline style 还要高比如结果为：1093比1100，按位比较，从左到右，只要一位高于则立即胜出，否则继续比较。 46.要动态改变层中内容可以使用的方法？innerHTML，innerText","link":"/2017/09/15/interview-HTML-CSS/"}],"tags":[{"name":"React","slug":"React","link":"/tags/React/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"ngSanitize","slug":"ngSanitize","link":"/tags/ngSanitize/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"button","slug":"button","link":"/tags/button/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"CSS3","slug":"CSS3","link":"/tags/CSS3/"},{"name":"图片","slug":"图片","link":"/tags/图片/"},{"name":"懒加载， 原生JS","slug":"懒加载，-原生JS","link":"/tags/懒加载，-原生JS/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"阿里字体","slug":"阿里字体","link":"/tags/阿里字体/"},{"name":"util","slug":"util","link":"/tags/util/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"}],"categories":[{"name":"React","slug":"React","link":"/categories/React/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"Angular","slug":"Angular","link":"/categories/Angular/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"util","slug":"Javascript/util","link":"/categories/Javascript/util/"},{"name":"canvas","slug":"Javascript/canvas","link":"/categories/Javascript/canvas/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"面试","slug":"面试","link":"/categories/面试/"},{"name":"阿里字体","slug":"Javascript/阿里字体","link":"/categories/Javascript/阿里字体/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"前端","slug":"面试/前端","link":"/categories/面试/前端/"}]}